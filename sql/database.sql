-- MySQL dump 10.16  Distrib 10.1.35-MariaDB, for Linux (x86_64)
--
-- Host: localhost    Database: rest
-- ------------------------------------------------------
-- Server version	10.1.35-MariaDB

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `alembic_version`
--

DROP TABLE IF EXISTS `alembic_version`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `alembic_version` (
  `version_num` varchar(32) NOT NULL,
  PRIMARY KEY (`version_num`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `alembic_version`
--

LOCK TABLES `alembic_version` WRITE;
/*!40000 ALTER TABLE `alembic_version` DISABLE KEYS */;
INSERT INTO `alembic_version` VALUES ('1cdf4eea5787');
/*!40000 ALTER TABLE `alembic_version` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) DEFAULT NULL,
  `slug` varchar(128) DEFAULT NULL,
  `content` text,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  `raw_content` text,
  PRIMARY KEY (`id`),
  UNIQUE KEY `slug` (`slug`),
  UNIQUE KEY `title` (`title`),
  KEY `category_id` (`category_id`)
) ENGINE=MyISAM AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1,'调教日志1','teach-sss-1','<h2 id=\"_1\">崧崧崧调教日志</h2>\n<h3 id=\"_2\">前言</h3>\n<p>写这个专题的原因  ===&gt; 完全是因为我的好基友崧崧崧明明都快本科毕业了, 感觉无论是情商还是专项能力都上不了台面了(可以说是完全不会了), 于是开始了这个项目.</p>\n<p>由于我的基友崧崧崧完全不会任何代码, 也不知道自己的目标, 选择C++无疑是最为合适的.</p>\n<h3 id=\"_3\">如何调教</h3>\n<p>采用一问一答方式, 如</p>\n<p>2018-5-15\n1. 安装dev c++, 和 Cygwin\n2. 使用c++ 编写程序 输出 hello,world</p>\n<h3 id=\"_4\">开始</h3>\n<p>2018-5-15</p>\n<ol>\n<li>安装dev-C++, 和 Cygwin</li>\n<li>使用c++ 编写程序 输出 hello,world</li>\n</ol>\n<p>参考资料: <a href=\"https://www.cygwin.com/\">cygwin官网</a> <a href=\"https://sourceforge.net/projects/orwelldevcpp/\">dev-C++下载</a> <a href=\"https://blog.csdn.net/sqlaowen/article/details/54645241\">win下安装Cygwin</a></p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\nint main() {\n    cout &lt;&lt; &quot;hello,world!&quot; &lt;&lt; endl;\n    return 0;\n}</code></pre>\n\n\n<p>2018-5-16</p>\n<p>很好你已经跨出了第一步, 但对于程序员来说, 每一行代码都是回忆, 所以你需要使用版本控制工具记录每一个历史,又由于磁盘总能出现问题,你需要将你的代码托管在云上,下面就是你需要做的</p>\n<ol>\n<li>\n<p>注册github, 下载git版本控制工具</p>\n</li>\n<li>\n<p>在github创建Hello,World仓库, 将昨天写的main.cpp推送到Hello,World仓库</p>\n</li>\n<li>\n<p>阅读 C++Prime Plus 第一,二章</p>\n</li>\n<li>\n<p>查阅资料,善用搜索引擎, 回答出C++的基本类型</p>\n</li>\n</ol>\n<pre class=\"codehilite\"><code class=\"language-bash\">$git init\n$ git add main.cpp\n$ git commit -m &quot;hello world&quot;\n$ git remote add origin https://github.com/ArtPop6/HelloWorld.git\n$ git push -u origin master</code></pre>\n\n\n<p>阅读第一二章小结：\n1. 泛型即是指具有在多种数据类型上皆可操作的含义，是把数据类型作为一种参数传递进来。\n2. 用文本编辑器编写的程序保存的文件即为源代码，编译源代码为机器语言包含编译后程序的文件即为目标代码，再和启动代码与库代码结合起来生成可执行代码。\n3. 要让窗口一直开着，直到按任何键则需输入cin.get();在return语句前（读取下一次键击，按下enter键之前让程序等待）\n4. 预处理编译指令#include,编译指令using namespace。\n5. return返回语句用来结束函数。\n6. C语言中省略函数返回类型相当于函数返回类型为int。\n7. (void）说明函数不接受任何参数。void main()说明函数不返回任何值。\n8. 编译器在main（）中无返回语句则默认以return 0；结尾。\n9. 运行c++程序通常以main()函数开始执行。没有main（）函数则程序不完整。\n10. #include<iostream>（预处理操作，将文件内容添加到程序中） using namespace std;提供输入输出工具。 \n11. 名称空间有助于组织程序，区分不同版本。\n12. 太晚了，不看了，剩下的明天看。</p>\n<p>C++基本类型：</p>\n<ol>\n<li>bool</li>\n<li>char</li>\n<li>wchar_t</li>\n<li>char16_t</li>\n<li>char32_t  </li>\n<li>short</li>\n<li>int</li>\n<li>long  </li>\n<li>float</li>\n<li>double</li>\n</ol>\n<p>2018-5-17</p>\n<p>从今日正式开始C++的学习， 下面是你今天的任务</p>\n<ol>\n<li>C++的输入与输出，分别输入自己的个人信息， 并输出。</li>\n<li>C++的所有的条件语句， 并在下方写出例子。</li>\n<li>阅读C++ Prime Plus 第三章 并写出总结。</li>\n</ol>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main() {\n    long number;\n    string name;\n    int classnum;\n    cout &lt;&lt; &quot;请输入学号，姓名，班级&quot; &lt;&lt;endl;\n    cin &gt;&gt; number &gt;&gt; name &gt;&gt; classnum;\n     cout &lt;&lt; &quot;学号：&quot; &lt;&lt; number &lt;&lt; endl &lt;&lt; &quot;姓名：&quot; &lt;&lt; name &lt;&lt; endl &lt;&lt; &quot;班级：&quot; &lt;&lt; classnum &lt;&lt; endl;\n    return 0;\n}</code></pre>\n\n\n<p>If else 语句</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int a;\n    int b;\n    cout &lt;&lt; &quot; 请输入a,b的值 &quot; &lt;&lt; endl;\n    cin &gt;&gt; a &gt;&gt; b; \n    if (a&gt;b)\n    cout &lt;&lt; a &lt;&lt; endl;\n    else\n    cout &lt;&lt; b &lt;&lt; endl;\n    return 0;\n}</code></pre>\n\n\n<p>Switch语句</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    char grade;\n    cout &lt;&lt; &quot;请输入你的成绩：&quot; &lt;&lt;endl; \n    cin &gt;&gt; grade;\n    switch(grade) \n    {\n        case \'A\' :\n            cout &lt;&lt; &quot;很棒&quot; &lt;&lt; endl;\n            break;\n        case \'B\' :\n            cout &lt;&lt; &quot;优秀&quot; &lt;&lt; endl;\n            break;\n        case \'C\' :\n            cout &lt;&lt; &quot;良好&quot; &lt;&lt; endl;\n            break;\n        case \'D\' :\n            cout &lt;&lt; &quot;加油&quot; &lt;&lt; endl;\n            break;  \n        default :\n            cout &lt;&lt; &quot;无效的成绩&quot; &lt;&lt; endl;\n\n    }\n    cout &lt;&lt; grade &lt;&lt; endl;\n\n    return 0;\n}</code></pre>\n\n\n<p>阅读小结：\n1.endl为特殊C++符号，即重起一行；\n2.cout的拼接；</p>\n<p>2018-5-18</p>\n<p>今天的任务是：\n1. 完善昨优化天的任务 \n2. 阅读C++ Prime Plus 第四章， 写下小节\n3. 使用C++编一个猜数字的游戏 提示 srand\n4. 算法 字符串反转</p>\n<pre class=\"codehilite\"><code>&quot;name&quot; -&gt; &quot;eman&quot;</code></pre>\n\n\n<p>1.PigLan要的Else if语句：</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std; \nint main() {\n    int a;\n    cin &gt;&gt; a;\n    if(a&gt;90)\n    cout &lt;&lt; &quot;优秀&quot; &lt;&lt; endl;\n    else if(a&gt;70)\n    cout &lt;&lt; &quot;良好&quot; &lt;&lt; endl;\n    else if(a&gt;=60) \n    cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;\n    else \n    cout &lt;&lt; &quot;不合格&quot; &lt;&lt; endl; \n    return 0;\n}</code></pre>\n\n\n<p>While条件语句：将数字逆序输出</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int n = 0;\n    int bit_num = 0;\n    cout &lt;&lt; &quot;please input your number:&quot;;\n\n    cin &gt;&gt;n;\n\n    while(n)\n    {\n        bit_num = n % 10;\n        n = n / 10;\n        cout &lt;&lt; bit_num;\n    }\n    cout&lt;&lt;endl;\n\n    return 0;\n}</code></pre>\n\n\n<p>endl是一个函数参数，类型为函数指针。然后会执行”return (<em>endl) (</em>this);“语句，即执行endl函数。endl函数输出一个换行符，并刷新输出缓冲区。</p>\n<p>2.第四章：复合类型\n1，声明数组的通用格式：\ntypeName arrayName[arraySize];\n其中arraySize必须是已知的；\n2，有效下标值的重要性；\n3，只有在定义数组的时候才能初始化数组，不能将数组值赋值给另一个数组，但可以使用下标给数组元素赋值。将一部分赋值，则其他部分会赋值为0；\n4，中间存在空字符的不能称之为字符串；\n5，将数组初始化为字符串，用大量单引号且必须加上空字符，或者用字符串常量初始化字符串用一个双引号括起，隐式得包括了结尾的空字符，输入时会自动加上结尾的空字符，用static关键字来初始化数组。\n6，字符串常量不能与字符常量进行互换，\"S\"不是字符常量，是字符\'S\'与\'\\0\'组成的字符串，实际上表示字符串所在内存地址。\n7，拼接字符串常量，拼接时不会在被连接字符串之间添加空格；\n8，在数组中使用字符串；</p>\n<p>3.猜数字游戏</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include&lt;iostream&gt; \n#include &lt;cstdlib&gt;  \n#include&lt;time.h&gt;  \nusing namespace std;  \nint Random()      //此函数用于产生随机数   \n{  \n    int Random_number;  \n    srand(time(0));//获取系统时间来作为种子  \n    Random_number=1+rand()%1000;      \n    return Random_number;  \n}  \nint main()  \n{  \n    int Random_number,guss_number;  \n    char yes_no;  \n    while(true)  \n    {  \n        Random_number=random();\n        cout&lt;&lt;Random_number&lt;&lt;endl;  \n        cout&lt;&lt;&quot;I have a number between 1 and 1000&quot;&lt;&lt;endl;  \n        cout&lt;&lt;&quot;Can you guess my number?&quot;&lt;&lt;endl;  \n        cout&lt;&lt;&quot;Please type your first guess：&quot;;  \n        cin&gt;&gt;guss_number;  \n        while(guss_number&lt;1||guss_number&gt;1000)  \n        {  \n            cout&lt;&lt;&quot;Input error,once again!&quot;;  \n            cin&gt;&gt;guss_number;  \n        }   \n        while(true)  \n        {  \n            if(guss_number==Random_number)  \n            {  \n                cout&lt;&lt;&quot;Excellent! You guessed the number!&quot;&lt;&lt;endl;  \n                cout&lt;&lt;&quot;Would you like to play again (y or n)?：&quot; ;  \n                cin&gt;&gt;yes_no;  \n                if(yes_no==\'n\')  \n                {  \n                    exit(0);    //返回操作系统   \n                }  \n                else  \n                {  \n                    break;      //跳出第一层循环   \n                }  \n            }  \n            if(guss_number&lt;Random_number)  \n            {  \n                cout&lt;&lt;&quot;Too low．Try again &quot;;  \n                cin&gt;&gt;guss_number;  \n                while(guss_number&lt;1||guss_number&gt;1000)  \n                {  \n                    cout&lt;&lt;&quot;Input error,once again!&quot;;  \n                    cin&gt;&gt;guss_number;  \n                }   \n            }  \n            if(guss_number&gt;Random_number)  \n            {  \n                cout&lt;&lt;&quot;Too high．Try again &quot;;  \n                cin&gt;&gt;guss_number;  \n                while(guss_number&lt;1||guss_number&gt;1000)  \n                {  \n                    cout&lt;&lt;&quot;Input error,once again!&quot;;  \n                    cin&gt;&gt;guss_number;  \n                }   \n            }  \n        }  \n    }  \n    return 0;  \n}   </code></pre>\n\n\n<p>4.字符串反转算法：</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nvoid Reverse(char *s,int n){\n    for(int i=0,j=n-1;i&lt;j;i++,j--){\n        char c=s[i];\n        s[i]=s[j];\n        s[j]=c;\n    }\n}\nint main()\n{\n    char s[]=&quot;name&quot;;\n    Reverse(s,4);\n    cout&lt;&lt;s&lt;&lt;endl;\n    return 0;\n}</code></pre>\n\n\n<p>2018-5-19\n下面是你今天的任务</p>\n<ol>\n<li>优化字符串反转方法=&gt; Reverse(char *s)</li>\n<li>字符串替换 使 \"s as just do it $3 axs\" -&gt; \"s-as-just-do-it-$3-axs\"</li>\n<li>阅读 C++ Prime Plus 第五章 写下阅读小节</li>\n</ol>\n<p>1.借鉴网上然后自己打的：</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std; \nint main(int argc, char** argv) {\n    char str[] = &quot;name&quot;;\n    string s = str;\n    reverse(s.begin(),s.end());\n    cout &lt;&lt; s &lt;&lt; endl;\n    return 0;\n}</code></pre>\n\n\n<p>2.字符串替换：(自己想的你信不信)</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std; \nint main() {\n    char str[50] = &quot;s as just do it $3 axs&quot;;\n    char *s = str; //声明一个指针指向字符串数组开头\n    int count = 0; \n     while (*s)\n    {\n        if (*s == \' \')\n        {\n            *s = \'-\';//当指针指向的数为空的时候换为&quot;-&quot; \n        }      \n        s++;//继续向下找 \n    }\n    cout &lt;&lt; str &lt;&lt; endl;\n    return 0;\n}</code></pre>\n\n\n<p>3.小结：\n1.a++意味着使用a的当前值计算表达式，然后将a的值加一，而++b为先将b的值加一然后用新的值计算表达式\n2.略（520）</p>\n<p>2018-5-20</p>\n<ol>\n<li>写一个算法, 输入一个整数, 输出 对应的因数, 如 8 -&gt; 1x8, 2x4 (顺序)</li>\n<li>算法: 冒泡排序, 二分法排序</li>\n<li>查阅资料, 列出C++所有的关键字</li>\n</ol>\n<p>1，不会顺序按格式输出。。</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int n;\n    int m;  \n    cin &gt;&gt; n;\n    for(int i = 1;i &lt; n; i++)\n    {\n        if(n%i==0)\n        {\n            m=n/i;\n            cout &lt;&lt; m &lt;&lt; endl;\n        }       \n    }       \n    return 0;\n}</code></pre>\n\n\n<p>2.二分法明天看。。。</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;  \nusing namespace std;\nint main()\n{\n int a[16];\n int i,j;\n cout&lt;&lt;&quot;请输入各个数字：&quot;&lt;&lt;\' \';\n for(i=0;i&lt;10;i++)\n  cin&gt;&gt;a[i];\n for(j=1;j&lt;10;j++)\n for(i=0;i&lt;10-j;i++)  \n{     if(a[i]&gt;a[i+1])\n   {\n    int temp=a[i];\n    a[i]=a[i+1];\n    a[i+1]=temp;\n   }\n\n  }\n for(i=0;i&lt;10;i++)\n cout&lt;&lt;a[i]&lt;&lt;\' \';\n cout&lt;&lt;endl;\n return 0;\n}</code></pre>\n\n\n<p>4.\n1. asm\n2. auto\n3. *_cast\n4. bool、true、false\n5. break、cotinue、goto \n6. switch、case、default\n7. catch、throw、try\n8. char、wchar_t\n9. const、volatile\n10. struct、class、union\n11. new、delete\n12. do、for、while\n13. 数值类型，如 int、double、float、short、long、signed、unsigned\n14. if和else\n15. enum\n16. explicit\n17. export\n18. extern\n19. friend\n20. inline\n21. mutable\n22. namespace\n23. operator　　\n24. public、protected、private\n25. register\n26. return\n27. static\n28. sizeof\n29. template\n30. this\n31. typedef\n32. virtual\n33. typeid\n34. typename\n35. using\n36. void\n37. pigLan</p>\n<p>2018-5-21\n1. 完善二分排序\n2. 快速排序\n3. 阅读算法突击一， 二章</p>\n<p>1.不会做。。</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nvoid Merge(int arr[], int start, int end);\nvoid Combine(int arr[], int start, int m, int end);\nint main(){\n    int arr[8] {6, 5, 3, 1, 8, 7, 2 ,4};\n    merge(arr[8],0,8);\n    return 0;\n\n}\n\nvoid Merge(int arr[], int start, int end) {\n    if (start &lt;= end)\n    int mid=(start+end)/2;\n    Merge(arr, start, mid);\n    Merge(arr, mid+1, end);\n    combine(arr, start, m, end);\n}\n\nvoid Combine(int arr[], int start, int m, int end) {\n    int length=end-start+1;\n    int temp[]=new int[length];\n    int i=start;\n    int j=m+1;\n    int c=0;\n    while(i&lt;=m &amp;&amp;j&lt;=end){\n        if(arr[i]&lt;arr[j]){\n            temp[c]=arr[i];\n                i++;\n                c++;\n            }else{\n                temp[c]=arr[j];\n                j++;\n                c++;\n            }\n        }\n        cout &lt;&lt; temp[] &lt;&lt; endl;\n\n}</code></pre>\n\n\n<p>2.</p>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include&lt;iostream&gt;  \nusing namespace std;  \nvoid quickSort(int a[],int,int);  \nint main()  \n{  \n    int array[]={34,65,12,43,67,5,78,10,3,70},k;  \n    int len=sizeof(array)/sizeof(int);  \n    cout&lt;&lt;&quot;The orginal arrayare:&quot;&lt;&lt;endl;  \n    for(k=0;k&lt;len;k++)  \n        cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;;  \n    cout&lt;&lt;endl;  \n    quickSort(array,0,len-1);  \n    cout&lt;&lt;&quot;The sorted arrayare:&quot;&lt;&lt;endl;  \n    for(k=0;k&lt;len;k++)  \n        cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;;  \n    cout&lt;&lt;endl;  \n    system(&quot;pause&quot;);  \n    return 0;  \n}  \n\nvoid quickSort(int s[], int l, int r)  \n{  \n    if (l&lt; r)  \n    {        \n        int i = l, j = r, x = s[l];  \n        while (i &lt; j)  \n        {  \n            while(i &lt; j &amp;&amp; s[j]&gt;= x) \n                j--;   \n            if(i &lt; j)  \n                s[i++] = s[j];  \n            while(i &lt; j &amp;&amp; s[i]&lt; x)\n                i++;   \n            if(i &lt; j)  \n                s[j--] = s[i];  \n        }  \n        s[i] = x;  \n        quickSort(s, l, i - 1);  \n        quickSort(s, i + 1, r);  \n    }  \n}  </code></pre>\n\n\n<p>2018-5-22</p>\n<ol>\n<li>完成昨天未完成的</li>\n</ol>','2018-05-15 04:09:05','2018-05-22 02:06:47',1,'## 崧崧崧调教日志\n\n### 前言\n\n写这个专题的原因  ===> 完全是因为我的好基友崧崧崧明明都快本科毕业了, 感觉无论是情商还是专项能力都上不了台面了(可以说是完全不会了), 于是开始了这个项目.\n\n由于我的基友崧崧崧完全不会任何代码, 也不知道自己的目标, 选择C++无疑是最为合适的.\n\n### 如何调教\n\n采用一问一答方式, 如\n\n2018-5-15\n1. 安装dev c++, 和 Cygwin\n2. 使用c++ 编写程序 输出 hello,world\n\n### 开始\n\n2018-5-15\n\n1. 安装dev-C++, 和 Cygwin\n2. 使用c++ 编写程序 输出 hello,world\n\n参考资料: [cygwin官网](https://www.cygwin.com/) [dev-C++下载](https://sourceforge.net/projects/orwelldevcpp/) [win下安装Cygwin](https://blog.csdn.net/sqlaowen/article/details/54645241)\n\n```c++\n#include <iostream>\n\nusing namespace std;\nint main() {\n	cout << \"hello,world!\" << endl;\n	return 0;\n}\n```\n\n2018-5-16\n\n很好你已经跨出了第一步, 但对于程序员来说, 每一行代码都是回忆, 所以你需要使用版本控制工具记录每一个历史,又由于磁盘总能出现问题,你需要将你的代码托管在云上,下面就是你需要做的\n\n1. 注册github, 下载git版本控制工具\n\n2. 在github创建Hello,World仓库, 将昨天写的main.cpp推送到Hello,World仓库\n\n3. 阅读 C++Prime Plus 第一,二章\n\n4. 查阅资料,善用搜索引擎, 回答出C++的基本类型\n\n```bash\n$git init\n$ git add main.cpp\n$ git commit -m \"hello world\"\n$ git remote add origin https://github.com/ArtPop6/HelloWorld.git\n$ git push -u origin master\n```\n\n阅读第一二章小结：\n1. 泛型即是指具有在多种数据类型上皆可操作的含义，是把数据类型作为一种参数传递进来。\n2. 用文本编辑器编写的程序保存的文件即为源代码，编译源代码为机器语言包含编译后程序的文件即为目标代码，再和启动代码与库代码结合起来生成可执行代码。\n3. 要让窗口一直开着，直到按任何键则需输入cin.get();在return语句前（读取下一次键击，按下enter键之前让程序等待）\n4. 预处理编译指令#include,编译指令using namespace。\n5. return返回语句用来结束函数。\n6. C语言中省略函数返回类型相当于函数返回类型为int。\n7. (void）说明函数不接受任何参数。void main()说明函数不返回任何值。\n8. 编译器在main（）中无返回语句则默认以return 0；结尾。\n9. 运行c++程序通常以main()函数开始执行。没有main（）函数则程序不完整。\n10. #include<iostream>（预处理操作，将文件内容添加到程序中） using namespace std;提供输入输出工具。 \n11. 名称空间有助于组织程序，区分不同版本。\n12. 太晚了，不看了，剩下的明天看。\n\n\nC++基本类型：\n\n1. bool\n2. char\n3. wchar_t\n4. char16_t\n5. char32_t  \n6. short\n7. int\n8. long  \n9. float\n10. double\n\n 2018-5-17\n\n从今日正式开始C++的学习， 下面是你今天的任务\n\n1. C++的输入与输出，分别输入自己的个人信息， 并输出。\n2. C++的所有的条件语句， 并在下方写出例子。\n3. 阅读C++ Prime Plus 第三章 并写出总结。\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n	long number;\n	string name;\n	int classnum;\n	cout << \"请输入学号，姓名，班级\" <<endl;\n	cin >> number >> name >> classnum;\n	 cout << \"学号：\" << number << endl << \"姓名：\" << name << endl << \"班级：\" << classnum << endl;\n	return 0;\n}\n```\n\nIf else 语句\n\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n	int a;\n	int b;\n	cout << \" 请输入a,b的值 \" << endl;\n	cin >> a >> b; \n	if (a>b)\n	cout << a << endl;\n	else\n	cout << b << endl;\n	return 0;\n}\n```\n\nSwitch语句\n\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n	char grade;\n	cout << \"请输入你的成绩：\" <<endl; \n	cin >> grade;\n	switch(grade) \n	{\n		case \'A\' :\n			cout << \"很棒\" << endl;\n			break;\n		case \'B\' :\n			cout << \"优秀\" << endl;\n			break;\n		case \'C\' :\n		    cout << \"良好\" << endl;\n		    break;\n		case \'D\' :\n			cout << \"加油\" << endl;\n			break;	\n		default :\n            cout << \"无效的成绩\" << endl;\n		\n	}\n	cout << grade << endl;\n\n	return 0;\n}\n```\n\n阅读小结：\n1.endl为特殊C++符号，即重起一行；\n2.cout的拼接；\n\n2018-5-18\n\n今天的任务是：\n1. 完善昨优化天的任务 \n2. 阅读C++ Prime Plus 第四章， 写下小节\n3. 使用C++编一个猜数字的游戏 提示 srand\n4. 算法 字符串反转\n```\n\"name\" -> \"eman\"\n```\n\n1.PigLan要的Else if语句：\n```c++\n#include <iostream>\nusing namespace std; \nint main() {\n	int a;\n	cin >> a;\n	if(a>90)\n	cout << \"优秀\" << endl;\n	else if(a>70)\n	cout << \"良好\" << endl;\n	else if(a>=60) \n	cout << \"一般\" << endl;\n	else \n	cout << \"不合格\" << endl; \n	return 0;\n}\n```\n\n\n\nWhile条件语句：将数字逆序输出\n```c++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int n = 0;\n    int bit_num = 0;\n    cout << \"please input your number:\";\n\n    cin >>n;\n\n    while(n)\n    {\n        bit_num = n % 10;\n        n = n / 10;\n        cout << bit_num;\n    }\n    cout<<endl;\n\n    return 0;\n}\n```\nendl是一个函数参数，类型为函数指针。然后会执行”return (*endl) (*this);“语句，即执行endl函数。endl函数输出一个换行符，并刷新输出缓冲区。\n\n2.第四章：复合类型\n1，声明数组的通用格式：\ntypeName arrayName[arraySize];\n其中arraySize必须是已知的；\n2，有效下标值的重要性；\n3，只有在定义数组的时候才能初始化数组，不能将数组值赋值给另一个数组，但可以使用下标给数组元素赋值。将一部分赋值，则其他部分会赋值为0；\n4，中间存在空字符的不能称之为字符串；\n5，将数组初始化为字符串，用大量单引号且必须加上空字符，或者用字符串常量初始化字符串用一个双引号括起，隐式得包括了结尾的空字符，输入时会自动加上结尾的空字符，用static关键字来初始化数组。\n6，字符串常量不能与字符常量进行互换，\"S\"不是字符常量，是字符\'S\'与\'\\0\'组成的字符串，实际上表示字符串所在内存地址。\n7，拼接字符串常量，拼接时不会在被连接字符串之间添加空格；\n8，在数组中使用字符串；\n\n3.猜数字游戏\n\n```c++\n#include<iostream> \n#include <cstdlib>  \n#include<time.h>  \nusing namespace std;  \nint Random()      //此函数用于产生随机数   \n{  \n    int Random_number;  \n    srand(time(0));//获取系统时间来作为种子  \n    Random_number=1+rand()%1000;      \n    return Random_number;  \n}  \nint main()  \n{  \n    int Random_number,guss_number;  \n    char yes_no;  \n    while(true)  \n    {  \n        Random_number=random();\n        cout<<Random_number<<endl;  \n        cout<<\"I have a number between 1 and 1000\"<<endl;  \n        cout<<\"Can you guess my number?\"<<endl;  \n        cout<<\"Please type your first guess：\";  \n        cin>>guss_number;  \n        while(guss_number<1||guss_number>1000)  \n        {  \n            cout<<\"Input error,once again!\";  \n            cin>>guss_number;  \n        }   \n        while(true)  \n        {  \n            if(guss_number==Random_number)  \n            {  \n                cout<<\"Excellent! You guessed the number!\"<<endl;  \n                cout<<\"Would you like to play again (y or n)?：\" ;  \n                cin>>yes_no;  \n                if(yes_no==\'n\')  \n                {  \n                    exit(0);    //返回操作系统   \n                }  \n                else  \n                {  \n                    break;      //跳出第一层循环   \n                }  \n            }  \n            if(guss_number<Random_number)  \n            {  \n                cout<<\"Too low．Try again \";  \n                cin>>guss_number;  \n                while(guss_number<1||guss_number>1000)  \n                {  \n                    cout<<\"Input error,once again!\";  \n                    cin>>guss_number;  \n                }   \n            }  \n            if(guss_number>Random_number)  \n            {  \n                cout<<\"Too high．Try again \";  \n                cin>>guss_number;  \n                while(guss_number<1||guss_number>1000)  \n                {  \n                    cout<<\"Input error,once again!\";  \n                    cin>>guss_number;  \n                }   \n            }  \n        }  \n    }  \n    return 0;  \n}   \n```\n\n4.字符串反转算法：\n\n```c++\n#include <iostream>\nusing namespace std;\nvoid Reverse(char *s,int n){\n    for(int i=0,j=n-1;i<j;i++,j--){\n        char c=s[i];\n        s[i]=s[j];\n        s[j]=c;\n    }\n}\nint main()\n{\n    char s[]=\"name\";\n    Reverse(s,4);\n    cout<<s<<endl;\n    return 0;\n}\n```\n\n2018-5-19\n下面是你今天的任务\n\n1. 优化字符串反转方法=> Reverse(char *s)\n2. 字符串替换 使 \"s as just do it $3 axs\" -> \"s-as-just-do-it-$3-axs\"\n3. 阅读 C++ Prime Plus 第五章 写下阅读小节\n\n1.借鉴网上然后自己打的：\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std; \nint main(int argc, char** argv) {\n	char str[] = \"name\";\n	string s = str;\n	reverse(s.begin(),s.end());\n	cout << s << endl;\n	return 0;\n}\n```\n\n2.字符串替换：(自己想的你信不信)\n\n```c++\n#include <iostream>\n#include<string>\nusing namespace std; \nint main() {\n	char str[50] = \"s as just do it $3 axs\";\n	char *s = str; //声明一个指针指向字符串数组开头\n	int count = 0; \n	 while (*s)\n    {\n        if (*s == \' \')\n        {\n            *s = \'-\';//当指针指向的数为空的时候换为\"-\" \n        }      \n        s++;//继续向下找 \n    }\n    cout << str << endl;\n	return 0;\n}\n```\n\n3.小结：\n1.a++意味着使用a的当前值计算表达式，然后将a的值加一，而++b为先将b的值加一然后用新的值计算表达式\n2.略（520）\n\n2018-5-20\n\n1. 写一个算法, 输入一个整数, 输出 对应的因数, 如 8 -> 1x8, 2x4 (顺序)\n2. 算法: 冒泡排序, 二分法排序\n3. 查阅资料, 列出C++所有的关键字\n\n1，不会顺序按格式输出。。\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n	int n;\n	int m;	\n	cin >> n;\n	for(int i = 1;i < n; i++)\n	{\n		if(n%i==0)\n		{\n		    m=n/i;\n		    cout << m << endl;\n		}		\n	}		\n	return 0;\n}\n```\n\n2.二分法明天看。。。\n```c++\n#include <iostream>  \nusing namespace std;\nint main()\n{\n int a[16];\n int i,j;\n cout<<\"请输入各个数字：\"<<\' \';\n for(i=0;i<10;i++)\n  cin>>a[i];\n for(j=1;j<10;j++)\n for(i=0;i<10-j;i++)  \n{     if(a[i]>a[i+1])\n   {\n    int temp=a[i];\n    a[i]=a[i+1];\n    a[i+1]=temp;\n   }\n   \n  }\n for(i=0;i<10;i++)\n cout<<a[i]<<\' \';\n cout<<endl;\n return 0;\n}\n```\n\n4.\n1. asm\n2. auto\n3. *_cast\n4. bool、true、false\n5. break、cotinue、goto \n6. switch、case、default\n7. catch、throw、try\n8. char、wchar_t\n9. const、volatile\n10. struct、class、union\n11. new、delete\n12. do、for、while\n13. 数值类型，如 int、double、float、short、long、signed、unsigned\n14. if和else\n15. enum\n16. explicit\n17. export\n18. extern\n19. friend\n20. inline\n21. mutable\n22. namespace\n23. operator　　\n24. public、protected、private\n25. register\n26. return\n27. static\n28. sizeof\n29. template\n30. this\n31. typedef\n32. virtual\n33. typeid\n34. typename\n35. using\n36. void\n37. pigLan\n\n2018-5-21\n1. 完善二分排序\n2. 快速排序\n3. 阅读算法突击一， 二章\n\n1.不会做。。\n```c++\n#include <iostream>\nusing namespace std;\nvoid Merge(int arr[], int start, int end);\nvoid Combine(int arr[], int start, int m, int end);\nint main(){\n    int arr[8] {6, 5, 3, 1, 8, 7, 2 ,4};\n    merge(arr[8],0,8);\n    return 0;\n    \n}\n\nvoid Merge(int arr[], int start, int end) {\n    if (start <= end)\n    int mid=(start+end)/2;\n    Merge(arr, start, mid);\n    Merge(arr, mid+1, end);\n    combine(arr, start, m, end);\n}\n\nvoid Combine(int arr[], int start, int m, int end) {\n    int length=end-start+1;\n    int temp[]=new int[length];\n    int i=start;\n    int j=m+1;\n    int c=0;\n    while(i<=m &&j<=end){\n        if(arr[i]<arr[j]){\n            temp[c]=arr[i];\n                i++;\n                c++;\n            }else{\n                temp[c]=arr[j];\n                j++;\n                c++;\n            }\n        }\n        cout << temp[] << endl;\n\n}\n```\n\n2.\n```c++\n#include<iostream>  \nusing namespace std;  \nvoid quickSort(int a[],int,int);  \nint main()  \n{  \n    int array[]={34,65,12,43,67,5,78,10,3,70},k;  \n    int len=sizeof(array)/sizeof(int);  \n    cout<<\"The orginal arrayare:\"<<endl;  \n    for(k=0;k<len;k++)  \n        cout<<array[k]<<\",\";  \n    cout<<endl;  \n    quickSort(array,0,len-1);  \n    cout<<\"The sorted arrayare:\"<<endl;  \n    for(k=0;k<len;k++)  \n        cout<<array[k]<<\",\";  \n    cout<<endl;  \n    system(\"pause\");  \n    return 0;  \n}  \n  \nvoid quickSort(int s[], int l, int r)  \n{  \n    if (l< r)  \n    {        \n        int i = l, j = r, x = s[l];  \n        while (i < j)  \n        {  \n            while(i < j && s[j]>= x) \n                j--;   \n            if(i < j)  \n                s[i++] = s[j];  \n            while(i < j && s[i]< x)\n                i++;   \n            if(i < j)  \n                s[j--] = s[i];  \n        }  \n        s[i] = x;  \n        quickSort(s, l, i - 1);  \n        quickSort(s, i + 1, r);  \n    }  \n}  \n```\n\n2018-5-22\n\n1. 完成昨天未完成的\n\n'),(4,'ubuntu配置','ubuntu-config','<p>这里是我的ubuntu配置</p>\n<p><img alt=\"68766284_p0.png\" src=\"https://buglan.org/static/images/68766284_p0.png\" /></p>\n<p><img alt=\"ubuntudesktop.png\" src=\"https://buglan.org/static/images/ubuntu-desktop.png\" /></p>\n<h2 id=\"_1\">常用软件</h2>\n<pre class=\"codehilite\"><code class=\"language-bash\">sudo apt install git\n\nsudo apt-get install gnome-tweak-tool\n\nsudo apt install htop\n\n#　zsh &amp; oh-my-zsh\nsudo apt install zsh\nsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;\n\n# chrome\nsudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/\nwget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install google-chrome-stable</code></pre>\n\n\n<h2 id=\"anaconda\">anaconda</h2>\n<ol>\n<li>在官网<a href=\"https://www.anaconda.com/download/\">下载</a></li>\n<li>cd 相应目录</li>\n<li>sh anaconda.sh</li>\n<li>按提示执行</li>\n<li>source ~/.bashrc or ~/.zshrc</li>\n<li>如果输入python 依旧不是anaconda\n的环境,则在~/.bashrc or ~/.zshrc 上添加  export PATH=\"/home/<username>/anaconda3/bin:$PATH\"</li>\n</ol>\n<h2 id=\"_2\">美化桌面</h2>\n<p>桌面主题</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">sudo apt install arc-theme</code></pre>\n\n\n<p>图标主题</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">sudo add-apt-repository ppa:papirus/papirus\nsudo apt-get update\nsudo apt-get install papirus-icon-theme\n#　在gnome-tweak-tool 切换图标</code></pre>\n\n\n<h3 id=\"_3\">字体</h3>\n<p><a href=\"https://sourcefoundry.org/hack/\">hack</a>\n1. 下载后在桌面解压安装\n2. 在gnome-tweak-tool 切换字体</p>\n<h3 id=\"gnome-shell\">gnome-shell</h3>\n<ol>\n<li>\n<p>在此<a href=\"https://extensions.gnome.org/extension/19/user-themes/\">网站</a>下载user-themes 并在 gnome-tweak-tool里开启</p>\n</li>\n<li>\n<p>在此<a href=\"https://www.gnome-look.org/browse/cat/134/\">网站</a>下下载中意的主题, 我自己使用的是arc-dark主题</p>\n</li>\n</ol>\n<h2 id=\"_4\">美化终端</h2>\n<h3 id=\"oh-my-zsh\">oh-my-zsh主题</h3>\n<ol>\n<li>sudo vim ~/.zshrc</li>\n<li>ZSH_THEME=\"ys\"</li>\n</ol>\n<h3 id=\"_5\">终端颜色主题</h3>\n<ol>\n<li>使用molokai配色  <a href=\"https://github.com/BUGLAN/vimrc\">下载</a></li>\n<li>cd vimrc mv .dircolors ~/.dircolors</li>\n<li>在~/.bashrc 或者 ~/.zshrc 中 找到 eval $(dircolors -b $HOME/.momlkaicolor) 相同格式(没有就添加)</li>\n<li>将 -b 后面改为自己的dircolors. </li>\n<li>然后 source ~/.bashr or ~/.zshrc</li>\n</ol>\n<pre class=\"codehilite\"><code class=\"language-shell\">#　我的配置\neval $(dircolors -b $HOME/.momlkaicolor)\nif [ -n &quot;$LS_COLORS&quot; ]; then\n     zstyle \':completion:*\' list-colors ${(s.:.)LS_COLORS}\nfi</code></pre>\n\n\n<p>待续</p>','2018-05-17 07:59:30','2018-05-21 09:59:32',2,'这里是我的ubuntu配置\n\n![68766284_p0.png](https://buglan.org/static/images/68766284_p0.png)\n\n\n![ubuntudesktop.png](https://buglan.org/static/images/ubuntu-desktop.png)\n\n\n## 常用软件\n\n```bash\nsudo apt install git\n\nsudo apt-get install gnome-tweak-tool\n\nsudo apt install htop\n\n#　zsh & oh-my-zsh\nsudo apt install zsh\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n\n# chrome\nsudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/\nwget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install google-chrome-stable\n\n```\n\n## anaconda\n\n1. 在官网[下载](https://www.anaconda.com/download/)\n2. cd 相应目录\n3. sh anaconda.sh\n4. 按提示执行\n5. source ~/.bashrc or ~/.zshrc\n6. 如果输入python 依旧不是anaconda\n的环境,则在~/.bashrc or ~/.zshrc 上添加  export PATH=\"/home/<username>/anaconda3/bin:$PATH\"\n\n## 美化桌面\n\n桌面主题\n```bash\nsudo apt install arc-theme\n```\n\n\n图标主题\n```bash\nsudo add-apt-repository ppa:papirus/papirus\nsudo apt-get update\nsudo apt-get install papirus-icon-theme\n#　在gnome-tweak-tool 切换图标\n```\n\n### 字体 \n\n[hack](https://sourcefoundry.org/hack/)\n1. 下载后在桌面解压安装\n2. 在gnome-tweak-tool 切换字体\n\n### gnome-shell\n\n1. 在此[网站](https://extensions.gnome.org/extension/19/user-themes/)下载user-themes 并在 gnome-tweak-tool里开启\n\n2. 在此[网站](https://www.gnome-look.org/browse/cat/134/)下下载中意的主题, 我自己使用的是arc-dark主题\n\n\n## 美化终端\n\n### oh-my-zsh主题\n1. sudo vim ~/.zshrc\n2. ZSH_THEME=\"ys\"\n\n### 终端颜色主题\n\n1. 使用molokai配色  [下载](https://github.com/BUGLAN/vimrc)\n2. cd vimrc mv .dircolors ~/.dircolors\n3. 在~/.bashrc 或者 ~/.zshrc 中 找到 eval $(dircolors -b $HOME/.momlkaicolor) 相同格式(没有就添加)\n4. 将 -b 后面改为自己的dircolors. \n5. 然后 source ~/.bashr or ~/.zshrc\n\n```shell\n#　我的配置\neval $(dircolors -b $HOME/.momlkaicolor)\nif [ -n \"$LS_COLORS\" ]; then\n     zstyle \':completion:*\' list-colors ${(s.:.)LS_COLORS}\nfi\n```\n\n待续\n\n'),(5,'vim-最强编辑器','vim-text-editor','<p><img alt=\"my_vimrc.png\" src=\"https://buglan.org/static/images/my_vimrc.png\" /></p>\n<h3 id=\"vim\">安装 vim</h3>\n<pre class=\"codehilite\"><code>sudo apt install vim</code></pre>\n\n\n<h3 id=\"vim_1\">查看vim版本</h3>\n<pre class=\"codehilite\"><code>vim --version</code></pre>\n\n\n<h3 id=\"vim_2\">vim 插件</h3>\n<h4 id=\"vbundle\"><a href=\"https://github.com/VundleVim/Vundle.vim\">Vbundle</a></h4>\n<p><img alt=\"vbundle\" src=\"https://camo.githubusercontent.com/bc559468e6623d18947ced1ef353f68f6116e45a/687474703a2f2f692e696d6775722e636f6d2f527565683743632e706e67\" /></p>\n<pre class=\"codehilite\"><code class=\"language-bash\"># 安装vbundle\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code></pre>\n\n\n<p>然后创建 ~/.vimrc</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">sudo vim ~/.vimrc</code></pre>\n\n\n<p>添加下列信息</p>\n<pre class=\"codehilite\"><code class=\"language-vim\">set nocompatible              &quot; 去除VI一致性,必须要添加\nfiletype on                  &quot; 必须要添加\n\n&quot; 设置包括vundle和初始化相关的runtime path\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\n&quot; 另一种选择, 指定一个vundle安装插件的路径\n&quot;call vundle#begin(\'~/some/path/here\')\n\n&quot; 让vundle管理插件版本,必须\nPlugin \'VundleVim/Vundle.vim\'\n\n&quot; 你的所有插件需要在下面这行之前\ncall vundle#end()            &quot; 必须\nfiletype plugin indent on    &quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本\n&quot; 忽视插件改变缩进,可以使用以下替代:\n&quot;filetype plugin on\n&quot;\n&quot; 常用的命令\n&quot; :PluginList       - 列出所有已配置的插件\n&quot; :PluginInstall     - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate\n&quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存\n&quot; :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件\n&quot;\n&quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ\n&quot; 将你自己对非插件片段放在这行之后</code></pre>\n\n\n<h4 id=\"nerdtree\"><a href=\"https://github.com/scrooloose/nerdtree\">NERDTree</a></h4>\n<p><img alt=\"NERDTree\" src=\"https://raw.githubusercontent.com/scrooloose/nerdtree/master/screenshot.png\" />\n在 ~/.vimrc 中</p>\n<pre class=\"codehilite\"><code class=\"language-vim\">Plugin \'scrooloose/nerdtree\'\n\n&quot; NERDTree setting\nlet NERDTreeShowLineNumbers=1\nlet NERDTreeAutoCenter=1\n&quot; 是否显示隐藏文件\nlet NERDTreeShowHidden=1\n&quot; 设置宽度\nlet NERDTreeWinSize=28\nautocmd StdinReadPre * let s:std_in=1\nautocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(&quot;s:std_in&quot;) | exe \'NERDTr    ee\' argv()[0] | wincmd p | ene | endif\n&quot; 按下 F2 调出/隐藏 NERDTree\nmap &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;\nautocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTreeType&quot;) &amp;&amp;b:NERDTreeType == &quot;primary    &quot;) | q | endif        </code></pre>\n\n\n<h3 id=\"air-line\"><a href=\"https://github.com/vim-airline/vim-airline\">air-line</a></h3>\n<p><img alt=\"air-line\" src=\"https://raw.githubusercontent.com/wiki/vim-airline/vim-airline/screenshots/demo.gif\" /></p>\n<pre class=\"codehilite\"><code class=\"language-vim\"> Plugin \'bling/vim-airline\'\n\n&quot;--------------------------------------------------------------------------\n&quot;vim-airline\n&quot;-------------------------------------------------------------------------- \n&quot;这个是安装字体后 必须设置此项&quot;\nlet g:airline_powerline_fonts = 1\n\n&quot;打开tabline功能,方便查看Buffer和切换,省去了minibufexpl插件\nlet g:airline#extensions#tabline#enabled = 1\nlet g:airline#extensions#tabline#buffer_nr_show = 1\n\n&quot;设置切换Buffer快捷键&quot;\nnnoremap &lt;C-tab&gt; :bn&lt;CR&gt;\nnnoremap &lt;C-s-tab&gt; :bp&lt;CR&gt;\n&quot; 关闭状态显示空白符号计数\nlet g:airline#extensions#whitespace#enabled = 0\nlet g:airline#extensions#whitespace#symbol = \'!\'\n&quot; 设置consolas字体&quot;前面已经设置过\n&quot;set guifont=Consolas\\ for\\ Powerline\\ FixedD:h11\nif !exists(\'g:airline_symbols\')\n    let g:airline_symbols = {}\nendif\n&quot;------------------------------air-line-------------------------------------</code></pre>\n\n\n<h4 id=\"youcompleteme\"><a href=\"https://github.com/Valloric/YouCompleteMe\">YouCompleteMe</a></h4>\n<p><img alt=\"YouCompleteMe\" src=\"https://camo.githubusercontent.com/1f3f922431d5363224b20e99467ff28b04e810e2/687474703a2f2f692e696d6775722e636f6d2f304f50346f6f642e676966\" /></p>\n<p>大名鼎鼎的补全插件\n最好阅读<a href=\"https://github.com/Valloric/YouCompleteMe\">官网</a>安装</p>\n<p>我的安装方法: 适用于高版本ubuntu</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">cd ~/.vim/bundle\ngit clone https://github.com/Valloric/YouCompleteMe.git\n\ncd ~/.vim/bundle/YouCompleteMe\n./install.py --clang-completer</code></pre>\n\n\n<h4 id=\"ale\"><a href=\"https://github.com/w0rp/ale\">ale</a></h4>\n<p><img alt=\"ale\" src=\"https://github.com/w0rp/ale/raw/master/img/example.gif?raw=true\" /></p>\n<blockquote>\n<p>ale替代syntastic ale是异步的比syntastic快多了</p>\n</blockquote>\n<h4 id=\"vim-plug\"><a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a></h4>\n<p><img alt=\"vim plug\" src=\"https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif\" /></p>\n<p>unix 安装</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre>\n\n\n<blockquote>\n<p>比vbundle更快的下载</p>\n</blockquote>\n<h4 id=\"identline\"><a href=\"https://github.com/Yggdroot/indentLine\">identLine</a></h4>\n<p><img alt=\"identLine\" src=\"https://camo.githubusercontent.com/77b20e2e707ac1d85fd8bc12f16b5b7b7e72e186/687474703a2f2f692e696d6775722e636f6d2f4b566930542e6a7067\" />\n<br>\npython 必备</p>\n<h4 id=\"auto-pairs\"><a href=\"https://github.com/jiangmiao/auto-pairs\">auto-pairs</a></h4>\n<p><br></p>\n<blockquote>\n<p>自动输入右括号</p>\n</blockquote>\n<h4 id=\"vim-better-whitespace\"><a href=\"https://github.com/ntpeters/vim-better-whitespace\">vim-better-whitespace</a></h4>\n<p><img alt=\"\" src=\"https://camo.githubusercontent.com/cceb11abfea4eb4359a8147074b85219e5b4314f/687474703a2f2f692e696d6775722e636f6d2f537437794874682e706e67\" /></p>\n<h4 id=\"vim-markdown\"><a href=\"https://github.com/plasticboy/vim-markdown\">vim-markdown</a></h4>\n<p><br></p>\n<blockquote>\n<p>markdown 的颜色高亮</p>\n</blockquote>\n<h4 id=\"markdown-previewvim\"><a href=\"https://github.com/iamcco/markdown-preview.vim\">markdown-preview.vim</a></h4>\n<p><img alt=\"\" src=\"https://cloud.githubusercontent.com/assets/5492542/15363504/839753be-1d4b-11e6-9ac8-def4d7122e8d.gif\" />\n<br></p>\n<blockquote>\n<p>可以随光标的移动二移动</p>\n</blockquote>\n<h4 id=\"fcitxvim\"><a href=\"https://github.com/vim-scripts/fcitx.vim\">fcitx.vim</a></h4>\n<p><br></p>\n<blockquote>\n<p>解决中文输入的痛处</p>\n</blockquote>\n<h3 id=\"vimrc\">我的<a href=\"https://github.com/BUGLAN/vimrc\">.vimrc</a></h3>\n<p>注意: 如果你使用我的.vimrc文件 请将YouCompleteMe插件和相关选项注释\n然后编译安装YouCompleteMe 或者先编译安装YouCompleteMe</p>\n<hr />\n<h1 id=\"qaq\">QAQ</h1>\n<h2 id=\"1youcompletemepython\">1.我安装了<code>YouCompleteMe</code>但是补全不了python</h2>\n<p>答: 确定使用标准的python解释器运行脚本, ycm只支持标准Python解释器</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">/usr/bin/python install.py --clang-complete</code></pre>\n\n\n<h2 id=\"2arch-linux-ycm-shut-down\">2.我是<code>arch linux</code>但是执行脚本错误 , 一直提示ycm shut down</h2>\n<p>答: ycm中的一个clang依赖出问题了, 在执行脚本加上 <code>--system-libclang</code> 参数</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">python install.py --clang-complete --system-libclang</code></pre>\n\n\n<h2 id=\"3\">3.补全不了第三方模块</h2>\n<p>答: 如果你使用<code>anaconda</code>, 那么请你使用系统标准的python来执行脚本, 然后指定PATHONPATH, 将其放入.bashrc或者 .zshrc文件中</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">export PYTHONPATH=$PYTHONPATH:/home/lan/anaconda3/lib/python3.6/site-packages</code></pre>\n\n\n<h2 id=\"4youcompletemexxxso-error\">4.<code>YouCompleteMe</code>提示<code>xxx.so error</code></h2>\n<p>答: 将标准python的包复制到anaconda中, 如将/usr/lib/python3.6/ 中的 <code>lib-dynload</code>整个文件夹复制到anaconda3/lib/python3.6/下 覆盖掉原文件</p>\n<h2 id=\"5youcompleteme\">5.<code>YouCompleteMe</code>补全打字时闪烁, 即使只有一个匹配项,也会闪烁.</h2>\n<p>答: 将配置文件中的高亮当前行去掉. </p>\n<h2 id=\"neovim\">更新: 目前我已经迁移到neovim</h2>\n<p>由于插件过多就简要列举一下 更多点击 <a href=\"https://github.com/BUGLAN/dotfiles\">dotfiles</a></p>\n<p>下面我将介绍我现在使用多比较的插件</p>\n<h4 id=\"vim-straify\"><a href=\"https://github.com/mhinz/vim-startify\">vim-straify</a></h4>\n<p><img alt=\"\" src=\"https://github.com/mhinz/vim-startify/raw/master/images/startify-menu.png\" /></p>\n<p>vim 的启动页</p>\n<h4 id=\"vim-polyglot\"><a href=\"https://github.com/sheerun/vim-polyglot\">vim-polyglot</a></h4>\n<p>vim 语法高亮 支持很多 对于python来说增强了 <code>self</code>, <code>cls</code></p>\n<h4 id=\"deopletenvim\"><a href=\"https://github.com/Shougo/deoplete.nvim\">deoplete.nvim</a></h4>\n<p><img alt=\"\" src=\"https://github.com/mhartington/deoplete-typescript/raw/master/deoplete-tss.gif\" /></p>\n<p>deoplete.nvim 相对与 ycm 的好处是flicker几乎没有, ycm的表现在neovim上比vim8还不如</p>\n<h4 id=\"vim-autoformat\"><a href=\"https://github.com/Chiel92/vim-autoformat\">vim-autoformat</a></h4>\n<h4 id=\"vim-lazygutter\"><a href=\"https://github.com/airblade/vim-gitgutter\">vim-lazygutter</a></h4>\n<h4 id=\"ultisnips\"><a href=\"https://github.com/SirVer/ultisnips\">ultisnips</a></h4>\n<h4 id=\"vim-isort\"><a href=\"https://github.com/fisadev/vim-isort\">vim-isort</a></h4>\n<h4 id=\"leaderf\"><a href=\"https://github.com/Yggdroot/LeaderF\">LeaderF</a></h4>\n<h4 id=\"nerdcommenter\"><a href=\"https://github.com/scrooloose/nerdcommenter\">nerdcommenter</a></h4>\n<h4 id=\"vim-pydocstring\"><a href=\"https://github.com/heavenshell/vim-pydocstring\">vim-pydocstring</a></h4>\n<h4 id=\"tabular\"><a href=\"https://github.com/godlygeek/tabular\">tabular</a></h4>\n<h4 id=\"vim-easymotion\"><a href=\"https://github.com/easymotion/vim-easymotion\">vim-easymotion</a></h4>\n<h4 id=\"vim-surround\"><a href=\"https://github.com/tpope/vim-surround\">vim-surround</a></h4>\n<h4 id=\"rainbow\"><a href=\"https://github.com/luochen1990/rainbow\">rainbow</a></h4>\n<h4 id=\"vim-devicons\"><a href=\"https://github.com/ryanoasis/vim-devicons\">vim-devicons</a></h4>\n<h4 id=\"vim-youdao-translater\"><a href=\"https://github.com/ianva/vim-youdao-translater\">vim-youdao-translater</a></h4>\n<h4 id=\"vim-easy-align\"><a href=\"https://github.com/junegunn/vim-easy-align\">vim-easy-align</a></h4>\n<h4 id=\"fzfvim\"><a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a></h4>','2018-05-17 09:40:50','2018-05-20 02:00:09',2,'\n![my_vimrc.png](https://buglan.org/static/images/my_vimrc.png)\n\n### 安装 vim\n```\nsudo apt install vim\n```\n### 查看vim版本\n```\nvim --version\n```\n\n### vim 插件\n\n#### [Vbundle](https://github.com/VundleVim/Vundle.vim)\n\n![vbundle](https://camo.githubusercontent.com/bc559468e6623d18947ced1ef353f68f6116e45a/687474703a2f2f692e696d6775722e636f6d2f527565683743632e706e67)\n\n```bash\n# 安装vbundle\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n```\n\n然后创建 ~/.vimrc\n```bash\nsudo vim ~/.vimrc\n```\n\n添加下列信息\n```vim\nset nocompatible              \" 去除VI一致性,必须要添加\nfiletype on                  \" 必须要添加\n\n\" 设置包括vundle和初始化相关的runtime path\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\n\" 另一种选择, 指定一个vundle安装插件的路径\n\"call vundle#begin(\'~/some/path/here\')\n\n\" 让vundle管理插件版本,必须\nPlugin \'VundleVim/Vundle.vim\'\n\n\" 你的所有插件需要在下面这行之前\ncall vundle#end()            \" 必须\nfiletype plugin indent on    \" 必须 加载vim自带和插件相应的语法和文件类型相关脚本\n\" 忽视插件改变缩进,可以使用以下替代:\n\"filetype plugin on\n\"\n\" 常用的命令\n\" :PluginList       - 列出所有已配置的插件\n\" :PluginInstall     - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate\n\" :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存\n\" :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件\n\"\n\" 查阅 :h vundle 获取更多细节和wiki以及FAQ\n\" 将你自己对非插件片段放在这行之后\n```\n\n#### [NERDTree](https://github.com/scrooloose/nerdtree)\n\n![NERDTree](https://raw.githubusercontent.com/scrooloose/nerdtree/master/screenshot.png)\n在 ~/.vimrc 中\n```vim\nPlugin \'scrooloose/nerdtree\'\n\n\" NERDTree setting\nlet NERDTreeShowLineNumbers=1\nlet NERDTreeAutoCenter=1\n\" 是否显示隐藏文件\nlet NERDTreeShowHidden=1\n\" 设置宽度\nlet NERDTreeWinSize=28\nautocmd StdinReadPre * let s:std_in=1\nautocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists(\"s:std_in\") | exe \'NERDTr    ee\' argv()[0] | wincmd p | ene | endif\n\" 按下 F2 调出/隐藏 NERDTree\nmap <F2> :NERDTreeToggle<CR>\nautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTreeType\") &&b:NERDTreeType == \"primary    \") | q | endif        \n```\n\n### [air-line](https://github.com/vim-airline/vim-airline) \n\n![air-line](https://raw.githubusercontent.com/wiki/vim-airline/vim-airline/screenshots/demo.gif)\n\n```vim\n Plugin \'bling/vim-airline\'\n\n\"--------------------------------------------------------------------------\n\"vim-airline\n\"-------------------------------------------------------------------------- \n\"这个是安装字体后 必须设置此项\"\nlet g:airline_powerline_fonts = 1\n  \n\"打开tabline功能,方便查看Buffer和切换,省去了minibufexpl插件\nlet g:airline#extensions#tabline#enabled = 1\nlet g:airline#extensions#tabline#buffer_nr_show = 1\n  \n\"设置切换Buffer快捷键\"\nnnoremap <C-tab> :bn<CR>\nnnoremap <C-s-tab> :bp<CR>\n\" 关闭状态显示空白符号计数\nlet g:airline#extensions#whitespace#enabled = 0\nlet g:airline#extensions#whitespace#symbol = \'!\'\n\" 设置consolas字体\"前面已经设置过\n\"set guifont=Consolas\\ for\\ Powerline\\ FixedD:h11\nif !exists(\'g:airline_symbols\')\n    let g:airline_symbols = {}\nendif\n\"------------------------------air-line-------------------------------------\n```\n#### [YouCompleteMe](https://github.com/Valloric/YouCompleteMe)\n\n![YouCompleteMe](https://camo.githubusercontent.com/1f3f922431d5363224b20e99467ff28b04e810e2/687474703a2f2f692e696d6775722e636f6d2f304f50346f6f642e676966)\n\n大名鼎鼎的补全插件\n最好阅读[官网](https://github.com/Valloric/YouCompleteMe)安装\n\n我的安装方法: 适用于高版本ubuntu\n\n```bash\ncd ~/.vim/bundle\ngit clone https://github.com/Valloric/YouCompleteMe.git\n\ncd ~/.vim/bundle/YouCompleteMe\n./install.py --clang-completer\n```\n\n#### [ale](https://github.com/w0rp/ale)\n\n![ale](https://github.com/w0rp/ale/raw/master/img/example.gif?raw=true)\n\n> ale替代syntastic ale是异步的比syntastic快多了\n\n####　[vim-plug](https://github.com/junegunn/vim-plug)\n\n![vim plug](https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif)\n\nunix 安装\n\n```bash\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n```\n\n> 比vbundle更快的下载\n\n\n#### [identLine](https://github.com/Yggdroot/indentLine)\n![identLine](https://camo.githubusercontent.com/77b20e2e707ac1d85fd8bc12f16b5b7b7e72e186/687474703a2f2f692e696d6775722e636f6d2f4b566930542e6a7067)\n<br>\npython 必备\n\n####　[auto-pairs](https://github.com/jiangmiao/auto-pairs)\n<br>\n> 自动输入右括号\n\n####　[vim-better-whitespace](https://github.com/ntpeters/vim-better-whitespace)\n\n![](https://camo.githubusercontent.com/cceb11abfea4eb4359a8147074b85219e5b4314f/687474703a2f2f692e696d6775722e636f6d2f537437794874682e706e67)\n\n#### [vim-markdown](https://github.com/plasticboy/vim-markdown)\n<br>\n\n>  markdown 的颜色高亮\n\n#### [markdown-preview.vim](https://github.com/iamcco/markdown-preview.vim)\n\n![](https://cloud.githubusercontent.com/assets/5492542/15363504/839753be-1d4b-11e6-9ac8-def4d7122e8d.gif)\n<br>\n> 可以随光标的移动二移动\n\n#### [fcitx.vim](https://github.com/vim-scripts/fcitx.vim)\n\n<br>\n\n> 解决中文输入的痛处\n\n\n### 我的[.vimrc](https://github.com/BUGLAN/vimrc)\n\n注意: 如果你使用我的.vimrc文件 请将YouCompleteMe插件和相关选项注释\n然后编译安装YouCompleteMe 或者先编译安装YouCompleteMe\n\n***\n\n# QAQ\n## 1.我安装了`YouCompleteMe`但是补全不了python\n\n答: 确定使用标准的python解释器运行脚本, ycm只支持标准Python解释器\n\n```bash\n/usr/bin/python install.py --clang-complete\n```\n## 2.我是`arch linux`但是执行脚本错误 , 一直提示ycm shut down\n\n答: ycm中的一个clang依赖出问题了, 在执行脚本加上 `--system-libclang` 参数\n\n```bash\npython install.py --clang-complete --system-libclang\n```\n\n## 3.补全不了第三方模块\n\n答: 如果你使用`anaconda`, 那么请你使用系统标准的python来执行脚本, 然后指定PATHONPATH, 将其放入.bashrc或者 .zshrc文件中\n\n```bash\nexport PYTHONPATH=$PYTHONPATH:/home/lan/anaconda3/lib/python3.6/site-packages\n```\n\n## 4.`YouCompleteMe`提示`xxx.so error` \n答: 将标准python的包复制到anaconda中, 如将/usr/lib/python3.6/ 中的 `lib-dynload`整个文件夹复制到anaconda3/lib/python3.6/下 覆盖掉原文件\n\n## 5.`YouCompleteMe`补全打字时闪烁, 即使只有一个匹配项,也会闪烁.\n\n答: 将配置文件中的高亮当前行去掉. \n\n## 更新: 目前我已经迁移到neovim\n\n由于插件过多就简要列举一下 更多点击 [dotfiles](https://github.com/BUGLAN/dotfiles)\n\n下面我将介绍我现在使用多比较的插件\n\n#### [vim-straify](https://github.com/mhinz/vim-startify)\n\n![](https://github.com/mhinz/vim-startify/raw/master/images/startify-menu.png)\n\nvim 的启动页\n\n\n#### [vim-polyglot](https://github.com/sheerun/vim-polyglot)\n\nvim 语法高亮 支持很多 对于python来说增强了 `self`, `cls`\n\n#### [deoplete.nvim](https://github.com/Shougo/deoplete.nvim)\n\n![](https://github.com/mhartington/deoplete-typescript/raw/master/deoplete-tss.gif)\n\ndeoplete.nvim 相对与 ycm 的好处是flicker几乎没有, ycm的表现在neovim上比vim8还不如\n\n\n#### [vim-autoformat](https://github.com/Chiel92/vim-autoformat)\n#### [vim-lazygutter](https://github.com/airblade/vim-gitgutter)\n#### [ultisnips](https://github.com/SirVer/ultisnips)\n#### [vim-isort](https://github.com/fisadev/vim-isort)\n#### [LeaderF](https://github.com/Yggdroot/LeaderF)\n#### [nerdcommenter](https://github.com/scrooloose/nerdcommenter)\n#### [vim-pydocstring](https://github.com/heavenshell/vim-pydocstring)\n#### [tabular](https://github.com/godlygeek/tabular)\n#### [vim-easymotion](https://github.com/easymotion/vim-easymotion)\n#### [vim-surround](https://github.com/tpope/vim-surround)\n#### [rainbow](https://github.com/luochen1990/rainbow)\n#### [vim-devicons](https://github.com/ryanoasis/vim-devicons)\n#### [vim-youdao-translater](https://github.com/ianva/vim-youdao-translater)\n#### [vim-easy-align](https://github.com/junegunn/vim-easy-align)\n#### [fzf.vim](https://github.com/junegunn/fzf.vim)\n'),(7,'Please consider using UTF8MB4 in order to be unambiguous.','mysql8-utf8mb4','<p>记一次艰难的mysql之旅</p>\n<p>我最近学习vim, 于是安装了最新的ubuntu18.04和mysql8, 我在重写我的blog时发现, 只要进行数据库的操作, 查询, 插入等, 都会出现这样一个warning</p>\n<p><img alt=\"20182422001.png\" src=\"https://buglan.org/static/images/2018-24-22-001.png\" /></p>\n<p><img alt=\"image.png\" src=\"https://buglan.org/static/images/image.png\" /></p>\n<p>后来通过百度, 发现mysql中的utf8, 不是我印象中的编码utf-8, 而是utf8mb3的别名, 而utf8mb3 存在许多字符不支持, 例如emoji表情, 如果需要存入数据库, 就需要将编码装换为utf8mb4, 简单的说utf8mb4, 就是utf8mb3的超集, 兼容utf8mb3.</p>\n<p>尽管这是一个警告,不是一个错误, 但我的心里总是痒痒的.</p>\n<p>没办法,我必须要将这个警告去除</p>\n<p>我根据我以前的经验, 将SQLALCHEMY_DATABASE_URI 改为</p>\n<pre class=\"codehilite\"><code class=\"language-python\">SQLALCHEMY_DATABASE_URI = \'mysql+pymysql://root:root@localhost:3306/restblog?charset=utf8mb4\'</code></pre>\n\n\n<p>依旧出现\n<img alt=\"20182422001.png\" src=\"https://buglan.org/static/images/2018-24-22-001.png\" /></p>\n<p>重新创建数据库</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">create database DATABASE charset=utf8mb4;</code></pre>\n\n\n<p>依旧出现</p>\n<p>修改mysql.conf</p>\n<pre class=\"codehilite\"><code class=\"language-shell\">[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n\n[mysqld]\ncharacter-set-server = utf8mb4\ncollation-server = utf8mb4_unicode_ci\ninit_connect = \'SET NAMES utf8mb4\'\ncharacter-set-client-handshake = false\npid-file    = /var/run/mysqld/mysqld.pid\nsocket      = /var/run/mysqld/mysqld.sock\ndatadir     = /var/lib/mysql\nlog-error   = /var/log/mysql/error.log</code></pre>\n\n\n<pre class=\"codehilite\"><code class=\"language-bash\">/etc/init.d/mysql restart</code></pre>\n\n\n<p><img alt=\"20182026001.png\" src=\"https://buglan.org/static/images/2018-05/2018-20-26-001.png\" /></p>\n<p>这样应该可以了吧</p>\n<p>still\n<img alt=\"20182422001.png\" src=\"https://buglan.org/static/images/2018-24-22-001.png\" /></p>\n<p>没办法了我疯狂的百度, 谷歌, 分析源吗,依旧得不到解决.\n正当我准备放下我的坚持时, 忽然想到, mysql官方也有sqlalchemy的驱动, 于是去看了一下</p>\n<p><img alt=\"20184522001.png\" src=\"https://buglan.org/static/images/2018-45-22-001.png\" /></p>\n<p><img alt=\"20184522002.png\" src=\"https://buglan.org/static/images/2018-45-22-002.png\" /></p>\n<p>额这其中必定存在某种联系</p>\n<p>果然最终使用了mysql的驱动就行了=-=</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">pip install mysql-connector-python</code></pre>\n\n\n<pre class=\"codehilite\"><code class=\"language-python\">SQLALCHEMY_DATABASE_URI = \'mysql+mysqlconnector://root:root@localhost:3306/restblog?charset=utf8mb4\'</code></pre>\n\n\n<p>后续</p>\n<p>由于pymysql的警告使我转战了mysql-connector-python, 起初我以为我配置好了utf8mb4, 但是又出现了新的错误\n=-=没错是错误</p>\n<pre class=\"codehilite\"><code>LookupError: unknown encoding: utf8mb4</code></pre>\n\n\n<p>但这种错误并不是随时出现的而是在我进行行多对多的批量插入时才会出现</p>\n<pre class=\"codehilite\"><code class=\"language-python\"># error happend\narticle.tags = [Article.query.get_or_404() for id in args[\'tag_ids\'] if args[\'tag_ids\'] else []\ndb.session.add(article)\ndb.session.commit()</code></pre>\n\n\n<p>如果我需要避免这种错误就一次只插入一个, 有点丑的实现</p>\n<pre class=\"codehilite\"><code class=\"language-python\"># ugly code\nfor id in args[\'tag_ids\']:\n    article.tags.append(Tag.query.get_or_404(id))\n    db.session.add(article)\n    db.session.commit()\nif not args[\'tag_ids\']:\n    db.session.add(article)\n    db.session.commit()</code></pre>\n\n\n<p>这个错误也很很难修改, 如果实在需要修改就必须修改源码.</p>\n<p>最后, 我想了一下, 我也不需要utf-8, 尽管能使用emoji表情, 能用emoji表情做url =-= \n好吧, 最后让我放弃的原因是, 我服务器上的mysq 是5.1的而我本地机则是8(5.8)</p>\n<p>emoji表情\n<img alt=\"20180526001.png\" src=\"https://buglan.org/static/images/2018-05/2018-05-26-001.png\" /></p>\n<p>如果我最终解决了这个问题, 我会补充的.. </p>','2018-05-22 11:22:49','2018-05-22 11:55:04',2,'记一次艰难的mysql之旅\n\n我最近学习vim, 于是安装了最新的ubuntu18.04和mysql8, 我在重写我的blog时发现, 只要进行数据库的操作, 查询, 插入等, 都会出现这样一个warning\n\n![20182422001.png](https://buglan.org/static/images/2018-24-22-001.png)\n\n![image.png](https://buglan.org/static/images/image.png)\n\n后来通过百度, 发现mysql中的utf8, 不是我印象中的编码utf-8, 而是utf8mb3的别名, 而utf8mb3 存在许多字符不支持, 例如emoji表情, 如果需要存入数据库, 就需要将编码装换为utf8mb4, 简单的说utf8mb4, 就是utf8mb3的超集, 兼容utf8mb3.\n\n尽管这是一个警告,不是一个错误, 但我的心里总是痒痒的.\n\n没办法,我必须要将这个警告去除\n\n我根据我以前的经验, 将SQLALCHEMY\\_DATABASE\\_URI 改为\n\n```python\nSQLALCHEMY_DATABASE_URI = \'mysql+pymysql://root:root@localhost:3306/restblog?charset=utf8mb4\'\n```\n\n依旧出现\n![20182422001.png](https://buglan.org/static/images/2018-24-22-001.png)\n\n重新创建数据库\n\n```bash\ncreate database DATABASE charset=utf8mb4;\n```\n依旧出现\n\n修改mysql.conf\n\n```shell\n[client]\ndefault-character-set=utf8mb4\n \n[mysql]\ndefault-character-set=utf8mb4\n \n[mysqld]\ncharacter-set-server = utf8mb4\ncollation-server = utf8mb4_unicode_ci\ninit_connect = \'SET NAMES utf8mb4\'\ncharacter-set-client-handshake = false\npid-file    = /var/run/mysqld/mysqld.pid\nsocket      = /var/run/mysqld/mysqld.sock\ndatadir     = /var/lib/mysql\nlog-error   = /var/log/mysql/error.log\n```\n\n```bash\n/etc/init.d/mysql restart\n```\n\n![20182026001.png](https://buglan.org/static/images/2018-05/2018-20-26-001.png)\n\n这样应该可以了吧\n\n\nstill\n![20182422001.png](https://buglan.org/static/images/2018-24-22-001.png)\n\n没办法了我疯狂的百度, 谷歌, 分析源吗,依旧得不到解决.\n正当我准备放下我的坚持时, 忽然想到, mysql官方也有sqlalchemy的驱动, 于是去看了一下\n\n![20184522001.png](https://buglan.org/static/images/2018-45-22-001.png)\n\n\n![20184522002.png](https://buglan.org/static/images/2018-45-22-002.png)\n\n额这其中必定存在某种联系\n\n果然最终使用了mysql的驱动就行了=-=\n\n```bash\npip install mysql-connector-python\n```\n\n```python\nSQLALCHEMY_DATABASE_URI = \'mysql+mysqlconnector://root:root@localhost:3306/restblog?charset=utf8mb4\'\n```\n\n后续\n\n由于pymysql的警告使我转战了mysql-connector-python, 起初我以为我配置好了utf8mb4, 但是又出现了新的错误\n=-=没错是错误\n```\nLookupError: unknown encoding: utf8mb4\n```\n但这种错误并不是随时出现的而是在我进行行多对多的批量插入时才会出现\n\n```python\n# error happend\narticle.tags = [Article.query.get_or_404() for id in args[\'tag_ids\'] if args[\'tag_ids\'] else []\ndb.session.add(article)\ndb.session.commit()\n```\n如果我需要避免这种错误就一次只插入一个, 有点丑的实现\n```python\n# ugly code\nfor id in args[\'tag_ids\']:\n    article.tags.append(Tag.query.get_or_404(id))\n    db.session.add(article)\n    db.session.commit()\nif not args[\'tag_ids\']:\n    db.session.add(article)\n    db.session.commit()\n```\n\n这个错误也很很难修改, 如果实在需要修改就必须修改源码.\n\n最后, 我想了一下, 我也不需要utf-8, 尽管能使用emoji表情, 能用emoji表情做url =-= \n好吧, 最后让我放弃的原因是, 我服务器上的mysq 是5.1的而我本地机则是8(5.8)\n\nemoji表情\n![20180526001.png](https://buglan.org/static/images/2018-05/2018-05-26-001.png)\n\n如果我最终解决了这个问题, 我会补充的.. \n\n\n\n'),(8,'调教日志2','teach-sss-2','<p>现在是第二个星期了, 希望你坚持不懈, 这些都是成长中所必须</p>\n<p>合抱之木，生于毫末；\n九层之台，起于累土；\n千里之行，始于足下。</p>\n<p>2018-5-23</p>\n<ol>\n<li>列出常见算法</li>\n<li>阅读C++ prime plus第六章</li>\n</ol>\n<p>列出常见算法：\n基本的C++算法分为三类：排序算法、树算法、图算法。\n一. 排序算法：\n1. 基本O(n^2)排序算法： （对基本排序算法的时间复杂度分析主要考虑  比较次数、数据交换次数）\n2. 冒泡排序：针对数组、本地排序、需要交换数据。O(1)额外空间\n选择排序：一般针对数组、本地排序、需要交换数据。O(1)的额外空间\n3. 插入排序：可以是针对数组的本地排序，此时需要移动大片数据，但是比较次数是O(N<em>logN)。如果是针对链表，比较次数是O(N^2)，但是不需要交换数据。\n4. O(N</em>logN)算法\n5. 快速排序：针对数组的本地排序，时间复杂度平均O(N<em>logN),最坏时O(N^2)。空间复杂度O(1)\n6. 归并排序：可以针对数组，也可以针对链表。针对数组时时间复杂度为O(N</em>logN)，空间复杂度为O(N)\n7. 堆排序，堆排序是针对数组的本地排序，时间复杂度为O(N<em>logN)，空间复杂度为O(1)，对于降序排列时用最小堆，首先建立堆，然后将第一个元素（堆头）与组后一个元素交换。找到了排列的最后一个元素，然后再调整前N-1个元素为最小堆，依次类推，即完成排序。\n注意：堆得建立， 堆的建立的时间复杂度为O(N</em>logN)，可以有多种方法建立堆\n8. 基数排序\n数据的取值范围不大，利用bitmap\n9. 外排序\n归并排序，多路归并排序（利用堆实现多路归并排序）\n使用堆进行多路排序时，堆中的每个元素同附加上一个域，存放该元素来自那一路\n堆一般还可以用于TopK算法，求TopK最大可以使用K个元素的最小堆维护K个最大元素，对原始数组扫描一遍即可。</p>\n<p>二、树的算法\n树一般用链表实现，通常用树数据结构实现数据的快速插入、删除、查找。\n1. 平衡二叉查找树\nRB-Tree、 AVL、 Treap、 伸展树（无需存放额外信息）\n2. B树\n用于建立文件系统或数据库的索引。B树的设计目标是减少IO访问次数。B树也是一棵平衡树\n3. 二项树、二项堆、费波那奇堆</p>\n<p>三、图的算法\n1. 图的表示\n有向图、无向图 的 邻接表表示、矩阵表示\n2. 广度优先搜索、深度优先搜索\n广度优先搜索（BFS）：找到从单个源点到所有点得最短路径，适用于有向图、无向图。算法发杂度为O(V+E)，注意算法对应图的边没有权重。算法使用队列实现广度优先。算法使用三个辅助变量、color、paraent、distance数组。搜索后的parent构成广度优先树\n3. 深度优先搜索（DFS）：可以随意从一个节点开始，遍历树的所有节点，使用于有向图、无向图。搜索构成森林。算法通过递归方式实现，依次递归完成后可能只搜索整个连通树的部分节点，因此需要从新任意选择一个节点从新开始DFS，整个搜索结果构成搜索森林。算法使用三个辅助变量：color，v，f。v表示搜索到该节点时间，f表示该节点的邻接节点都扫描完成的时间。\n注意DFS可以完成拓扑排序。利用f出现时间的降序就是拓扑序，可以在深度优先搜索的过程中得到该排序。\nDFS算法还可以用于发现强连通分支。\n4. 最小生成树\n针对无向连通图的，常见的算法有 Kruskal算法和Prim算法\nKruskal算法\n将所有的边非降序排列，所有的顶点初始化为不相交集合，每次取一个边，如果该边属于不同的集合，则该边加入解集，同时更新不想交集合。注意：不想交集合实现有专门的数据结构。\nPrim算法\n该算法与Dijkstra算法类似，每次加入已覆盖集合A和未覆盖集合B之间最短的边。\n5. 最短路径\n有权值的最短路径问题。可以是有向图，可以是无向图。权值可以为负值。\n变种：点与点之间最短路径、固定终点最短路径、所有点之间最短路径、最长路径（将权值去负值利用bellman-ford算法即可）\nBellman-Ford算法\n惊醒V-1遍松弛遍历，每次遍历，按照一定顺序，依次将所有的边松弛一遍。结束后，对所有的边进行一次check，如果有边不符合松弛条件，则返回false，表明图中存在负权值的环（该特性可以用于检测有向图中得环），算法复杂度O(VE)\nDijkstra算法\n只能针对于正值的边。算法复杂度O(V^2)\n6. 求所有点之间的最短路径\n矩阵上得动态规划算法。\nFloyd-Warshall算法，d_ij(k) 表示从顶点i到顶点j，中间节点只包含{1、2、... k}的最短路径。d_ij(n)即为所求。\nFloyd-Warshall算法可以用于求任意两个顶点是否可达</p>\n<p>2018-5-24</p>\n<ol>\n<li>写出选择排序, 冒泡排序</li>\n<li>编写程序, 找出这篇文章所有的\'的\', 以及索引</li>\n<li>C++ prime Plus 第七章</li>\n</ol>\n<h3 id=\"1\">一. 1.冒泡排序：</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nvoid bubblesort(int arr[],int n);\nint main() {\n    int a[10]={0};\n    cout &lt;&lt; &quot;请输入10个数：&quot; &lt;&lt; endl;\n    for(int w=0;w&lt;10;w++)\n    {\n        cin &gt;&gt; a[w];\n    }   \n    //int size = sizeof(a);\n    bubblesort(a,10);\n    for(int k=0;k&lt;10;k++)\n    {\n        cout &lt;&lt; a[k] &lt;&lt; &quot; &quot;; \n    }   \n    return 0;\n}\nvoid bubblesort(int arr[],int n)\n{\n    for(int i=0;i&lt;n-1;i++)\n    for(int j=0;j&lt;n-1-i;j++)\n    {\n        if(arr[j]&gt;arr[j+1])\n        {\n            int temp;\n            temp=arr[j];\n            arr[j]=arr[j+1];\n            arr[j+1]=temp;\n        }\n    }\n}</code></pre>\n\n\n<h3 id=\"2\">2. 选择排序:</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include&lt;iostream&gt; \nusing namespace std;\nint main(){\n    int a[6];\n    int min,i,j,t,k;\n    for(int i=0;i&lt;6;i++)\n    {\n        cin &gt;&gt; a[i];\n    }\n    for(i=0;i&lt;6;i++)\n    {\n        min=i;\n        for(j=0;j&lt;6;j++)\n        {\n            if(a[min]&gt;a[j]){\n                t=a[j];\n                a[j]=a[min];\n                a[min]=t;\n            }\n        }\n\n        }\n        for(k=0;k&lt;6;k++)\n        {\n            cout &lt;&lt; a[k] &lt;&lt; &quot; &quot;;\n        }\n\n    }</code></pre>\n\n\n<h3 id=\"3\">3.小结：</h3>\n<p>按照是否基于比较操作，算法分为比较排序与非比较排序；\n1. 比较排序：带排序对象可以是任意数据类型，只需要知道如何比较两个对象大小；\n2. 定义一：基于比较的排序，需明确两个对象大小关系规则。自定义对象比较规则应该满足传递性与全序性（对任意a,b或者a&lt;=b,或者a&gt;=b）;\n3.  当存在a&lt;=b和a&gt;=b时，任何一个都可以排在前面，当要求排序稳定时，需保持初始序列的前后顺序。\n4. 比较排序算法的复杂度下界log 2 (n!);\n5. 定义二，合并多个有序列。将多个有序列合并成一个有序列。\n6. 定义三，前k小数；给定包含n个对象的序列，找出前k个最小的数；\n7. 梳排序\n梳排序作为冒泡排序得一种改进。\n8. 冒泡排序的思想是：对相邻元素进行两两比较，顺序相反则进行交换，每一趟会将最小或者最大元素“浮”到顶端，最终达到完全有序。\n9. 选择排序:简单选择排序是最简单直观的一种算法，基本思想是:每一趟从待排序的数据元素中选择最小（或者最大）的一个元素作为首元素，\n直到所有元素排完为止。不稳定排序，冒泡排序是相邻的比较，而选择排序是选定第一个元素与之后所有元素的一一比较。</p>\n<h3 id=\"_1\">二.找出所有的\"的\"</h3>\n<p>不会。</p>\n<h3 id=\"c-prime-plus\">三.C++ prime Plus 第七章</h3>\n<h5 id=\"_2\">小结：</h5>\n<ol>\n<li>c++自带一个包含函数的大型库（标准ANSI库加上多个c++类）</li>\n<li>使用c++函数必须完成如下工作：提供函数定义；提供函数原型；调用函数；</li>\n<li>库函数提供使用标准库头文件提供原型。</li>\n<li>strlen函数确定字符串长度。标准头文件cstring包含了该函数的原型。使其能随意使用该函数；</li>\n<li>创建自己的函数时，必须自行：定义，提供原型和调用。</li>\n<li>执行simple函数时，将暂停main中代码，执行完毕simple再执行main。\n7，使用了cout则需要using 编译指令；</li>\n<li>定义函数：函数分为两类：没有返回值和有返回值的函数；没有返回值则为void函数。\n void a(parameter list)\n {\nstatement(s);\nreturn;//可选，标记函数的结尾；\n}</li>\n<li>void cheers(int n){}</li>\n<li>有返回值的函数将生成一个值，并将它返回给调用函数，函数的类型被声明为返回值的类型；</li>\n<li>有返回值的函数，必须使用返回语句。以便将值返回给调用函数，值可以是变量常量或者是表达式(return x*x)，结果类型必须是typename类型；</li>\n<li>返回值类型不能是数组，可以当成结构或对象组成部分返回。</li>\n<li>函数是如何返回值的，</li>\n<li>函数在执行完第一条返回语句后结束（if else）</li>\n<li>函数原型隐藏在include文件中；</li>\n</ol>\n<p>2018-5-26</p>\n<ol>\n<li>总结自己学习到的知识, 以列表形式列出来</li>\n<li>使用搜索引擎, 了解IT火热的名词(如Python, 区块链)</li>\n<li>\n<p>阅读C++ prime plus 第八章, 写下阅读小节</p>\n</li>\n<li>\n<p>区块链 : 一种新型的诚信货币</p>\n</li>\n<li>python: 最近火热的编程语言</li>\n</ol>\n<p>2018-5-27</p>\n<p>最近有点怠慢啊, 毕竟学习没有得到反馈, 上个星期的<a href=\"https://github.com/BUGLAN/teach-sss\">answer</a>出来了, 有了比对, 就会有动力了.希望你的成果能对的上你的努力.</p>\n<ol>\n<li>仔细比对, 发现不足</li>\n<li>C++ prime Plus 第七章</li>\n<li>crtl c, crtl v 是最low的行为</li>\n<li>阅读一篇英语文章, 只需理解大概意思(不要抠字眼)</li>\n</ol>\n<h3 id=\"_3\">一·</h3>\n<ol>\n<li>随机数生成：</li>\n</ol>\n<pre class=\"codehilite\"><code class=\"language-c++\">srand((unsigned)time(0)); \n\n\n\nint guess_num = min + rand() % (max + min - 1); </code></pre>\n\n\n<ol>\n<li>数组长度算法：</li>\n</ol>\n<pre class=\"codehilite\"><code class=\"language-c++\"> int length = (int)sizeof(arr) / sizeof(*arr); </code></pre>\n\n\n<h3 id=\"_4\">二，</h3>\n<ol>\n<li>原型描述了函数到编译器的接口，将函数返回值类型以及参数类型与数量告诉编译器</li>\n<li>函数原型不需要变量名，只需类型列表 void cheers（int）；</li>\n<li>原型帮助编译器做许多事，大大降低程序出错率，原型确保以下几点：编译器正确处理返回值，编译器检查使用的参数数目是否正确，检查使用的参数类型是否正确，若不正确转换为正确的类型；</li>\n<li>数组函数。</li>\n</ol>\n<p>2018-5-28</p>\n<ol>\n<li>完善之前的答案.</li>\n</ol>\n<p>2018-5-29</p>\n<ol>\n<li>写一个类, 列出注意事项</li>\n<li>完善这个类, 实现列表的各种方法</li>\n<li>C++ prime Plus 第八章</li>\n</ol>\n<h3 id=\"_5\">长期任务</h3>\n<ul>\n<li>阅读<a href=\"http://www.ruanyifeng.com/home.html\">阮一峰的网络日志</a>, 每天半小时</li>\n</ul>\n<h3 id=\"_6\">一：</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nclass Student\n{\n    public:\n        Student(string con_name,int con_id);\n        ~Student();\n        string get_stdname() const;\n        void print();\n    private:\n        string m_strName;\n        int m_nID;      \n};\nStudent::Student(string con_name,int con_id):m_strName(con_name)\n{\n    m_nID=con_id;\n } \n Student::~Student()\n {\n }\n string Student::get_stdname() const //定义常成员函数\n {\n    return m_strName;\n }\n void Student::print()//普通成员函数\n {\n    cout &lt;&lt; &quot;学生姓名:&quot; &lt;&lt; m_strName &lt;&lt; &quot;  &quot; &lt;&lt; &quot;学号:&quot; &lt;&lt; m_nID &lt;&lt;endl; \n } \n int main()\n {\n    Student std_yu(&quot;岳楠崧&quot;, 19);\n    std_yu.print();\n    system(&quot;pause&quot;);\n    return 0;\n\n }</code></pre>\n\n\n<hr />\n<h3 id=\"_7\">注意事项：</h3>\n<p>const成员函数不可以修改数据成员，成员函数声明为const可以保证成员函数不修改类的数据成员。但是如果该类含有指针，那么const成员函数就能修改指针所指对象。</p>\n<h3 id=\"_8\">三.</h3>\n<p>阅读第八章\n1. 内联函数运行速度快但占用内存。\n2. 使用内联函数应该在函数声明与定义中加上关键字inline.\n3. 声明引用变量别名&amp;。\n4. int &amp;指向int的引用，&amp;rodent地址。\n5. 引用变量必须在声明时初始化而指针不用。\n6. 引用变量与const指针相同。一旦引用始终效终。</p>\n<p>2018-5-30</p>\n<ol>\n<li>完善昨天的第二条: \"完善这个类, 实现列表的各种方法\"</li>\n</ol>\n<h3 id=\"_9\">一</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nclass List\n{\n    public:\n        List(int size=0)\n        {\n            head=new int[size];\n            length=size;            \n        }\n        ~List();\n        void put(int a);\n        int getE(int index);\n    private:\n        int *head;\n        int length;             \n};\nList::~List()\n{   \n}\nvoid List::put(int a)\n{\n    head[length]=a;\n    length++;   \n}\nint List::getE(int index)\n{\n    return head[index];\n}\nint main()\n{\n    List yu;\n    yu.put(3);\n    yu.getE[0];\n\n}</code></pre>\n\n\n<p>没写好</p>\n<h3 id=\"_10\">修改后的数组类代码：</h3>\n<pre class=\"codehilite\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nclass List\n{\n    private:\n        int *head;\n        int num;\n        int size;\n    public:\n        List(int s=100)\n        {\n            size=s;\n            head=new int[size];\n            num=0;          \n        }\n        ~List();\n        void put(int a);\n        int getE(int index);\n        void insert(int n,int m);\n        void del(int w);            \n};\nList::~List()\n{   \n}\nvoid List::put(int a)\n{\n    head[num]=a;\n    num++;\n    size++; \n}\nint List::getE(int index)\n{\n    return head[index];\n}\nvoid List::insert(int n,int m)\n{\n    num++;\n    for(;num&gt;=n;num--)\n    {\n        head[num]=head[num-1];\n    }\n    head[n-1]=m;\n } \nvoid List::del(int x)\n{\n    for(;x&lt;num-1;x++)\n    {\n        head[x]=head[x+1]; \n    } \n    num--;\n}\nint main()\n{\n    List yu;\n    yu.put(0);\n    yu.put(1);\n    yu.put(3);\n    yu.put(4);\n    yu.put(5);\n    yu.put(6);\n    yu.insert(3,2);\n    yu.del(3);\n    for(int i=0;i&lt;7;i++)\n    {\n        cout &lt;&lt; yu.getE(i) &lt;&lt; endl;\n    }\n}</code></pre>\n\n\n<h4 id=\"_11\">实现了查找，插入功能。但删除功能有点问题；</h4>\n<p>2018-5-31</p>\n<ol>\n<li>将两周的有效代码上传到github上】</li>\n</ol>\n<h4 id=\"main13cpp\">就传了一个<a href=\"https://github.com/ArtPop6/HelloWorld/blob/master/main13.cpp\">main13.cpp</a></h4>\n<p>2018-6-1\n儿童节快乐\n1. 理解一个cpp文件里面的变量作用域</p>\n<h4 id=\"_12\">答：</h4>\n<ol>\n<li><strong>作用域：</strong> 某标志符在程序中的有效区域。 </li>\n<li>作用域分<strong>全局作用域</strong>，<strong>局部作用域</strong>与<strong>类作用域</strong>。类的作用域就是类体，局部作用域就是函数的花括号内。</li>\n<li>高级别的作用域会被小的作用域覆盖，脱离了小的作用域，大的作用域会恢复，取的是小作用域。</li>\n<li>引用其他文件全局作用域加上关键字<strong>extern</strong>。</li>\n<li>使用作用域限定符：：在函数内部使用全局变量。  <strong>Exercise::</strong> Type Exercise::setVal(Type parm)</li>\n<li>作用域的查找会先在最小范围内查找，只考虑该项使用之前的声明语句。</li>\n<li>加了<strong>static</strong>或<strong>const</strong>关键字则作用域只能在本文件。降低文件之间的耦合度。当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值。 </li>\n</ol>\n<p>2018-6-2</p>\n<ol>\n<li>理解C++中程序各模块的生命周期</li>\n<li>阅读C++ prime plus 第九章</li>\n<li>学习<a href=\"https://dytiger.github.io/index.html\">打字</a>十分钟</li>\n</ol>\n<p>参考 <a href=\"https://www.icourse163.org/course/NWPU-494001\">慕课</a></p>\n<h3 id=\"_13\">一·</h3>\n<h4 id=\"_14\">按生命周期不同，对象可分为：局部对象，静态局部对象，全局对象，自由存储对象。</h4>\n<ol>\n<li>全局对象在main开始前被创建，main推出后销毁。</li>\n<li>静态局部对象在第一次进入作用域被创建，在main推出后销毁。</li>\n<li>局部对象在进入作用域时创建退出作用域时销毁，即退出函数体外则会被销毁。</li>\n<li>自由存储对象即new创建的对象会一直存在，直到用delete销毁。</li>\n</ol>\n<h3 id=\"_15\">二.</h3>\n<h4 id=\"_16\">单独编译：</h4>\n<ol>\n<li>c++鼓励将组件函数放在独立文件中。单独编译这些文件然后连接成可执行程序。</li>\n<li>将<strong>结构声明</strong>放入到头文件中，让每一个源代码文件包含该头文件，要修改结构声明时只需在头文件做一次改动即可。</li>\n<li>程序可分为三部分：<strong>头文件</strong>：包含结构声明和使用这些结构的函数的原型。<strong>源代码文件</strong>：包含与结构有关的函数的代码。<strong>源代码文件</strong>包含调用与结构相关的函数的代码。</li>\n<li>别的程序也可以引用这些头文件。</li>\n<li>不要将函数定义与变量声明放在头文件。</li>\n<li>函数头文件一般包含的内容：函数原型；使用#define或const定义的符号常量；结构声明；雷胜明；模板声明；内联函数。</li>\n<li>包含头文件时，使用代码 #include \"coodin.h\"而不用<coodin.h>。因为尖括号会使编译器在标准头文件中查找，而引号会使在当前工作目录或源代码目录中查找。</li>\n<li>同一文件只能将同一头文件包含一次（使用了包含另一头文件的头文件）用代码#ifndef  ..#endif    <strong>DK</strong></li>\n<li>c++使用四种不同方案存储数据（区别在于数据保存在内存中的时间，存储持续性）：自动存储持续性（函数内）；静态存储持续性（static）；线程存储持续性（变量用thread_local声明，生命周期与线程一样长）；动态存储持续性（new）</li>\n<li>新的定义隐藏以前的定义，以前的定义暂时不可见。</li>\n</ol>\n<h3 id=\"_17\">三.</h3>\n<p>打了。</p>\n<p>2018-6-3</p>\n<ol>\n<li>自省\n。。。</li>\n</ol>','2018-05-23 08:43:47','2018-05-24 23:21:13',1,'\n现在是第二个星期了, 希望你坚持不懈, 这些都是成长中所必须\n\n合抱之木，生于毫末；\n九层之台，起于累土；\n千里之行，始于足下。\n\n2018-5-23\n\n1. 列出常见算法\n2. 阅读C++ prime plus第六章\n\n列出常见算法：\n基本的C++算法分为三类：排序算法、树算法、图算法。\n一. 排序算法：\n1. 基本O(n^2)排序算法： （对基本排序算法的时间复杂度分析主要考虑  比较次数、数据交换次数）\n2. 冒泡排序：针对数组、本地排序、需要交换数据。O(1)额外空间\n选择排序：一般针对数组、本地排序、需要交换数据。O(1)的额外空间\n3. 插入排序：可以是针对数组的本地排序，此时需要移动大片数据，但是比较次数是O(N*logN)。如果是针对链表，比较次数是O(N^2)，但是不需要交换数据。\n4. O(N*logN)算法\n5. 快速排序：针对数组的本地排序，时间复杂度平均O(N*logN),最坏时O(N^2)。空间复杂度O(1)\n6. 归并排序：可以针对数组，也可以针对链表。针对数组时时间复杂度为O(N*logN)，空间复杂度为O(N)\n7. 堆排序，堆排序是针对数组的本地排序，时间复杂度为O(N*logN)，空间复杂度为O(1)，对于降序排列时用最小堆，首先建立堆，然后将第一个元素（堆头）与组后一个元素交换。找到了排列的最后一个元素，然后再调整前N-1个元素为最小堆，依次类推，即完成排序。\n注意：堆得建立， 堆的建立的时间复杂度为O(N*logN)，可以有多种方法建立堆\n8. 基数排序\n数据的取值范围不大，利用bitmap\n9. 外排序\n归并排序，多路归并排序（利用堆实现多路归并排序）\n使用堆进行多路排序时，堆中的每个元素同附加上一个域，存放该元素来自那一路\n堆一般还可以用于TopK算法，求TopK最大可以使用K个元素的最小堆维护K个最大元素，对原始数组扫描一遍即可。\n\n\n二、树的算法\n树一般用链表实现，通常用树数据结构实现数据的快速插入、删除、查找。\n1. 平衡二叉查找树\nRB-Tree、 AVL、 Treap、 伸展树（无需存放额外信息）\n2. B树\n用于建立文件系统或数据库的索引。B树的设计目标是减少IO访问次数。B树也是一棵平衡树\n3. 二项树、二项堆、费波那奇堆\n\n三、图的算法\n1. 图的表示\n有向图、无向图 的 邻接表表示、矩阵表示\n2. 广度优先搜索、深度优先搜索\n广度优先搜索（BFS）：找到从单个源点到所有点得最短路径，适用于有向图、无向图。算法发杂度为O(V+E)，注意算法对应图的边没有权重。算法使用队列实现广度优先。算法使用三个辅助变量、color、paraent、distance数组。搜索后的parent构成广度优先树\n3. 深度优先搜索（DFS）：可以随意从一个节点开始，遍历树的所有节点，使用于有向图、无向图。搜索构成森林。算法通过递归方式实现，依次递归完成后可能只搜索整个连通树的部分节点，因此需要从新任意选择一个节点从新开始DFS，整个搜索结果构成搜索森林。算法使用三个辅助变量：color，v，f。v表示搜索到该节点时间，f表示该节点的邻接节点都扫描完成的时间。\n注意DFS可以完成拓扑排序。利用f出现时间的降序就是拓扑序，可以在深度优先搜索的过程中得到该排序。\nDFS算法还可以用于发现强连通分支。\n4. 最小生成树\n针对无向连通图的，常见的算法有 Kruskal算法和Prim算法\nKruskal算法\n将所有的边非降序排列，所有的顶点初始化为不相交集合，每次取一个边，如果该边属于不同的集合，则该边加入解集，同时更新不想交集合。注意：不想交集合实现有专门的数据结构。\nPrim算法\n该算法与Dijkstra算法类似，每次加入已覆盖集合A和未覆盖集合B之间最短的边。\n5. 最短路径\n有权值的最短路径问题。可以是有向图，可以是无向图。权值可以为负值。\n变种：点与点之间最短路径、固定终点最短路径、所有点之间最短路径、最长路径（将权值去负值利用bellman-ford算法即可）\nBellman-Ford算法\n惊醒V-1遍松弛遍历，每次遍历，按照一定顺序，依次将所有的边松弛一遍。结束后，对所有的边进行一次check，如果有边不符合松弛条件，则返回false，表明图中存在负权值的环（该特性可以用于检测有向图中得环），算法复杂度O(VE)\nDijkstra算法\n只能针对于正值的边。算法复杂度O(V^2)\n6. 求所有点之间的最短路径\n矩阵上得动态规划算法。\nFloyd-Warshall算法，d_ij(k) 表示从顶点i到顶点j，中间节点只包含{1、2、... k}的最短路径。d_ij(n)即为所求。\nFloyd-Warshall算法可以用于求任意两个顶点是否可达\n\n\n2018-5-24\n\n1. 写出选择排序, 冒泡排序\n2. 编写程序, 找出这篇文章所有的\'的\', 以及索引\n3. C++ prime Plus 第七章\n\n### 一. 1.冒泡排序： \n```c++\n#include <iostream>\nusing namespace std;\nvoid bubblesort(int arr[],int n);\nint main() {\n	int a[10]={0};\n	cout << \"请输入10个数：\" << endl;\n	for(int w=0;w<10;w++)\n	{\n		cin >> a[w];\n	}	\n	//int size = sizeof(a);\n	bubblesort(a,10);\n	for(int k=0;k<10;k++)\n	{\n		cout << a[k] << \" \"; \n	}	\n	return 0;\n}\nvoid bubblesort(int arr[],int n)\n{\n	for(int i=0;i<n-1;i++)\n	for(int j=0;j<n-1-i;j++)\n	{\n		if(arr[j]>arr[j+1])\n		{\n			int temp;\n			temp=arr[j];\n			arr[j]=arr[j+1];\n			arr[j+1]=temp;\n		}\n	}\n}\n```\n\n### 2. 选择排序: \n```c++\n#include<iostream> \nusing namespace std;\nint main(){\n	int a[6];\n	int min,i,j,t,k;\n	for(int i=0;i<6;i++)\n	{\n		cin >> a[i];\n	}\n	for(i=0;i<6;i++)\n	{\n		min=i;\n		for(j=0;j<6;j++)\n		{\n			if(a[min]>a[j]){\n				t=a[j];\n				a[j]=a[min];\n				a[min]=t;\n			}\n		}\n		\n		}\n		for(k=0;k<6;k++)\n		{\n			cout << a[k] << \" \";\n		}\n		\n	}\n```\n### 3.小结： \n按照是否基于比较操作，算法分为比较排序与非比较排序；\n1. 比较排序：带排序对象可以是任意数据类型，只需要知道如何比较两个对象大小；\n2. 定义一：基于比较的排序，需明确两个对象大小关系规则。自定义对象比较规则应该满足传递性与全序性（对任意a,b或者a<=b,或者a>=b）;\n3.  当存在a<=b和a>=b时，任何一个都可以排在前面，当要求排序稳定时，需保持初始序列的前后顺序。\n4. 比较排序算法的复杂度下界log 2 (n!);\n5. 定义二，合并多个有序列。将多个有序列合并成一个有序列。\n6. 定义三，前k小数；给定包含n个对象的序列，找出前k个最小的数；\n7. 梳排序\n梳排序作为冒泡排序得一种改进。\n8. 冒泡排序的思想是：对相邻元素进行两两比较，顺序相反则进行交换，每一趟会将最小或者最大元素“浮”到顶端，最终达到完全有序。\n9. 选择排序:简单选择排序是最简单直观的一种算法，基本思想是:每一趟从待排序的数据元素中选择最小（或者最大）的一个元素作为首元素，\n直到所有元素排完为止。不稳定排序，冒泡排序是相邻的比较，而选择排序是选定第一个元素与之后所有元素的一一比较。\n\n### 二.找出所有的\"的\"\n不会。\n\n### 三.C++ prime Plus 第七章\n \n##### 小结：\n1. c++自带一个包含函数的大型库（标准ANSI库加上多个c++类）\n2. 使用c++函数必须完成如下工作：提供函数定义；提供函数原型；调用函数；\n3. 库函数提供使用标准库头文件提供原型。\n4. strlen函数确定字符串长度。标准头文件cstring包含了该函数的原型。使其能随意使用该函数；\n5. 创建自己的函数时，必须自行：定义，提供原型和调用。\n6. 执行simple函数时，将暂停main中代码，执行完毕simple再执行main。\n7，使用了cout则需要using 编译指令；\n8. 定义函数：函数分为两类：没有返回值和有返回值的函数；没有返回值则为void函数。\n void a(parameter list)\n {\nstatement(s);\nreturn;//可选，标记函数的结尾；\n}\n9. void cheers(int n){}\n10. 有返回值的函数将生成一个值，并将它返回给调用函数，函数的类型被声明为返回值的类型；\n11. 有返回值的函数，必须使用返回语句。以便将值返回给调用函数，值可以是变量常量或者是表达式(return x*x)，结果类型必须是typename类型；\n12. 返回值类型不能是数组，可以当成结构或对象组成部分返回。\n13. 函数是如何返回值的，\n14. 函数在执行完第一条返回语句后结束（if else）\n15. 函数原型隐藏在include文件中；\n\n2018-5-26\n\n1. 总结自己学习到的知识, 以列表形式列出来\n2. 使用搜索引擎, 了解IT火热的名词(如Python, 区块链)\n3. 阅读C++ prime plus 第八章, 写下阅读小节\n\n\n- 区块链 : 一种新型的诚信货币\n- python: 最近火热的编程语言\n\n2018-5-27\n\n最近有点怠慢啊, 毕竟学习没有得到反馈, 上个星期的[answer](https://github.com/BUGLAN/teach-sss)出来了, 有了比对, 就会有动力了.希望你的成果能对的上你的努力.\n\n1. 仔细比对, 发现不足\n2. C++ prime Plus 第七章\n3. crtl c, crtl v 是最low的行为\n4. 阅读一篇英语文章, 只需理解大概意思(不要抠字眼)\n### 一·\n1. 随机数生成：\n```c++\nsrand((unsigned)time(0)); \n\n\n \nint guess_num = min + rand() % (max + min - 1); \n```\n\n2. 数组长度算法：\n```c++\n int length = (int)sizeof(arr) / sizeof(*arr); \n```\n\n### 二，\n12. 原型描述了函数到编译器的接口，将函数返回值类型以及参数类型与数量告诉编译器\n13. 函数原型不需要变量名，只需类型列表 void cheers（int）；\n14. 原型帮助编译器做许多事，大大降低程序出错率，原型确保以下几点：编译器正确处理返回值，编译器检查使用的参数数目是否正确，检查使用的参数类型是否正确，若不正确转换为正确的类型；\n15. 数组函数。\n\n2018-5-28\n\n1. 完善之前的答案.\n\n2018-5-29\n\n1. 写一个类, 列出注意事项\n2. 完善这个类, 实现列表的各种方法\n3. C++ prime Plus 第八章\n\n### 长期任务\n- 阅读[阮一峰的网络日志](http://www.ruanyifeng.com/home.html), 每天半小时\n\n### 一：\n```c++\n#include <iostream>\n#include<string>\nusing namespace std;\nclass Student\n{\n	public:\n		Student(string con_name,int con_id);\n		~Student();\n		string get_stdname() const;\n		void print();\n	private:\n		string m_strName;\n	    int m_nID;		\n};\nStudent::Student(string con_name,int con_id):m_strName(con_name)\n{\n	m_nID=con_id;\n } \n Student::~Student()\n {\n }\n string Student::get_stdname() const //定义常成员函数\n {\n 	return m_strName;\n }\n void Student::print()//普通成员函数\n {\n 	cout << \"学生姓名:\" << m_strName << \"  \" << \"学号:\" << m_nID <<endl; \n } \n int main()\n {\n    Student std_yu(\"岳楠崧\", 19);\n    std_yu.print();\n    system(\"pause\");\n    return 0;\n    \n }\n```\n-----\n### 注意事项：\nconst成员函数不可以修改数据成员，成员函数声明为const可以保证成员函数不修改类的数据成员。但是如果该类含有指针，那么const成员函数就能修改指针所指对象。\n\n### 三.\n阅读第八章\n1. 内联函数运行速度快但占用内存。\n2. 使用内联函数应该在函数声明与定义中加上关键字inline.\n3. 声明引用变量别名&。\n4. int &指向int的引用，&rodent地址。\n5. 引用变量必须在声明时初始化而指针不用。\n6. 引用变量与const指针相同。一旦引用始终效终。\n\n2018-5-30\n\n1. 完善昨天的第二条: \"完善这个类, 实现列表的各种方法\"\n\n### 一\n```c++\n#include <iostream>\n#include<string>\nusing namespace std;\nclass List\n{\n	public:\n		List(int size=0)\n		{\n			head=new int[size];\n			length=size;		  	\n		}\n		~List();\n		void put(int a);\n		int getE(int index);\n	private:\n		int *head;\n		int length;				\n};\nList::~List()\n{	\n}\nvoid List::put(int a)\n{\n	head[length]=a;\n	length++;	\n}\nint List::getE(int index)\n{\n	return head[index];\n}\nint main()\n{\n	List yu;\n	yu.put(3);\n	yu.getE[0];\n	\n}\n```\n没写好\n\n### 修改后的数组类代码：\n```c++\n#include <iostream>\n#include<string>\nusing namespace std;\nclass List\n{\n	private:\n		int *head;\n		int num;\n		int size;\n	public:\n		List(int s=100)\n		{\n			size=s;\n			head=new int[size];\n			num=0;		  	\n		}\n		~List();\n		void put(int a);\n		int getE(int index);\n		void insert(int n,int m);\n		void del(int w);			\n};\nList::~List()\n{	\n}\nvoid List::put(int a)\n{\n	head[num]=a;\n	num++;\n	size++;	\n}\nint List::getE(int index)\n{\n	return head[index];\n}\nvoid List::insert(int n,int m)\n{\n	num++;\n	for(;num>=n;num--)\n	{\n		head[num]=head[num-1];\n	}\n	head[n-1]=m;\n } \nvoid List::del(int x)\n{\n	for(;x<num-1;x++)\n	{\n		head[x]=head[x+1]; \n	} \n	num--;\n}\nint main()\n{\n	List yu;\n	yu.put(0);\n	yu.put(1);\n	yu.put(3);\n	yu.put(4);\n	yu.put(5);\n	yu.put(6);\n	yu.insert(3,2);\n	yu.del(3);\n	for(int i=0;i<7;i++)\n	{\n		cout << yu.getE(i) << endl;\n	}\n}\n\n```\n\n#### 实现了查找，插入功能。但删除功能有点问题；\n\n2018-5-31\n\n1. 将两周的有效代码上传到github上】\n\n#### 就传了一个[main13.cpp](https://github.com/ArtPop6/HelloWorld/blob/master/main13.cpp)\n\n\n2018-6-1\n儿童节快乐\n1. 理解一个cpp文件里面的变量作用域\n\n#### 答：\n1. **作用域：** 某标志符在程序中的有效区域。 \n2. 作用域分**全局作用域**，**局部作用域**与**类作用域**。类的作用域就是类体，局部作用域就是函数的花括号内。\n3. 高级别的作用域会被小的作用域覆盖，脱离了小的作用域，大的作用域会恢复，取的是小作用域。\n4. 引用其他文件全局作用域加上关键字**extern**。\n5. 使用作用域限定符：：在函数内部使用全局变量。  **Exercise::** Type Exercise::setVal(Type parm)\n6. 作用域的查找会先在最小范围内查找，只考虑该项使用之前的声明语句。\n7. 加了**static**或**const**关键字则作用域只能在本文件。降低文件之间的耦合度。当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值。 \n\n\n2018-6-2\n\n1. 理解C++中程序各模块的生命周期\n2. 阅读C++ prime plus 第九章\n3. 学习[打字](https://dytiger.github.io/index.html)十分钟\n\n参考 [慕课](https://www.icourse163.org/course/NWPU-494001)\n\n### 一·\n#### 按生命周期不同，对象可分为：局部对象，静态局部对象，全局对象，自由存储对象。\n1. 全局对象在main开始前被创建，main推出后销毁。\n2. 静态局部对象在第一次进入作用域被创建，在main推出后销毁。\n3. 局部对象在进入作用域时创建退出作用域时销毁，即退出函数体外则会被销毁。\n4. 自由存储对象即new创建的对象会一直存在，直到用delete销毁。\n\n### 二.\n#### 单独编译：\n1. c++鼓励将组件函数放在独立文件中。单独编译这些文件然后连接成可执行程序。\n2. 将**结构声明**放入到头文件中，让每一个源代码文件包含该头文件，要修改结构声明时只需在头文件做一次改动即可。\n3. 程序可分为三部分：**头文件**：包含结构声明和使用这些结构的函数的原型。**源代码文件**：包含与结构有关的函数的代码。**源代码文件**包含调用与结构相关的函数的代码。\n4. 别的程序也可以引用这些头文件。\n5. 不要将函数定义与变量声明放在头文件。\n6. 函数头文件一般包含的内容：函数原型；使用#define或const定义的符号常量；结构声明；雷胜明；模板声明；内联函数。\n7. 包含头文件时，使用代码 #include \"coodin.h\"而不用<coodin.h>。因为尖括号会使编译器在标准头文件中查找，而引号会使在当前工作目录或源代码目录中查找。\n8. 同一文件只能将同一头文件包含一次（使用了包含另一头文件的头文件）用代码#ifndef  ..#endif    **DK**\n9. c++使用四种不同方案存储数据（区别在于数据保存在内存中的时间，存储持续性）：自动存储持续性（函数内）；静态存储持续性（static）；线程存储持续性（变量用thread_local声明，生命周期与线程一样长）；动态存储持续性（new）\n10. 新的定义隐藏以前的定义，以前的定义暂时不可见。\n### 三.\n打了。\n\n2018-6-3\n\n1. 自省\n。。。'),(11,'vim快捷键总结','vim-kewords','<h2 id=\"normal-mode\">Normal mode</h2>\n<h3 id=\"_1\">移动</h3>\n<ul>\n<li>h ←　向左移动</li>\n<li>j ↓　向下移动</li>\n<li>k ↑　向上移动</li>\n<li>l →　向右移动</li>\n<li>w 移动到下一个单词的首字母</li>\n<li>e 移动单词的末尾</li>\n<li>$ 移动光标到行尾</li>\n<li>^ 移动光标到行首</li>\n<li>0 移动光标到行首</li>\n<li>gg 当前光标直接跳转到文件第一行</li>\n<li>G 当前光标直接跳转到文件最后一行</li>\n<li>crtl-o 回到较旧位置</li>\n<li>ctrl-i 回到较新位置</li>\n<li>% 移动到配对的相应括号处</li>\n<li>zz 将当前行移动到中间(移动屏幕)</li>\n<li>zt 将当前行移动到第一行(移动屏幕)</li>\n<li>crtl-f 往上移动一个屏幕</li>\n<li>crtl-u 往下移动一个屏幕</li>\n<li>f {w} 移动到{w}字母上</li>\n</ul>\n<h3 id=\"_2\">更改</h3>\n<ul>\n<li>u 撤销上一次操作</li>\n<li>U 撤销整行的操作</li>\n<li>o 可以在光标下方打开新的一行并进入插入模式</li>\n<li>O 可以在光标上方打开新的一行</li>\n<li>a 光标之后插入文本</li>\n<li>A 移动到行尾并进入插入模式</li>\n<li>r 替换</li>\n<li>R 可连续替换多个字符</li>\n<li>crtl-r 撤销掉撤销的命令</li>\n<li>ctrl-g 用于显示当前光标所在位置和文件状态信息</li>\n<li>dd 删除整行</li>\n<li>de 当前光标位置删除到单词末尾</li>\n<li>dw 当前光标位置删除到下一个单词首部</li>\n<li>d$ 当前光标位置删除到行尾</li>\n<li>ce 当前光标位置删除到单词尾部, 并将删除的内容放入寄存器中, 进入插入模式</li>\n<li>cw 与ce行为一直</li>\n<li>dt) 删除直到右括号</li>\n</ul>\n<h3 id=\"_3\">查找</h3>\n<ul>\n<li>/ </li>\n<li>?</li>\n<li>n 查找并移动到下一个匹配的单词</li>\n<li>N 上一个</li>\n</ul>\n<h3 id=\"_4\">替换</h3>\n<ul>\n<li>:s/the/the 当前行第一个匹配thee为替换为the</li>\n<li>:s/thee/the/g 当前行所有thee为替换为the</li>\n<li>:%s/old/new/g 文件内替换所有的字符串</li>\n<li>:#,#s/old/new/g 两行内替换所有的字符串</li>\n<li>:%s/old/new/gc 进行全文替换时询问用户确认每个替换需添加 c 标志</li>\n</ul>\n<h3 id=\"_5\">执行外部命令</h3>\n<ul>\n<li>:!ls</li>\n<li>:!dir</li>\n</ul>\n<h3 id=\"_6\">复制粘贴</h3>\n<ul>\n<li>y 复制文本</li>\n<li>p 粘贴文本</li>\n<li>yw 复制一个单词 光标在单词末尾后</li>\n<li>ye 复制一个单词 光标在单词末尾</li>\n</ul>\n<p>bash 使用 vi 键盘阵列</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">set -o vi</code></pre>\n\n\n<h3 id=\"_7\">终端快捷键</h3>\n<ul>\n<li>ctrl+a: 移动到行首</li>\n<li>ctrl+e: 移动到行尾</li>\n<li>ctrl+b: 回移一个字符</li>\n<li>ctrl+f: 前移一个字符</li>\n<li>ctrl+r: 搜索历史命令</li>\n<li>ctrl+p: 上一个命令</li>\n<li>ctrl+n：下一个命令</li>\n<li>ctrl+h: 清除前一个字符</li>\n<li>ctrl+u: 清除当前命令</li>\n<li>ctrl+l: 清屏，替代 clear 命令</li>\n</ul>\n<h3 id=\"vim\">临时退出vim环境</h3>\n<ol>\n<li>\n<p>Ctrl-z 命令将当前的 Vi/Vim 进程放到后台执行，之后 shell 环境即可为你所用；fg 命令则将位于后台的 Vi/Vim 进程放到前台执行，这样我们就再次进入 Vi/Vim 操作界面并恢复到原先的编辑状态。</p>\n</li>\n<li>\n<p>在 Vi/Vim 的正常模式下输入 :sh即可进入 Linux/Unix shell 环境。在要返回到 Vi/Vim 编辑环境时，输入 exit 命令即可</p>\n</li>\n</ol>','2018-05-26 06:29:01','2018-05-26 06:29:01',2,'## Normal mode　\n\n### 移动\n- h ←　向左移动\n- j ↓　向下移动\n- k ↑　向上移动\n- l →　向右移动\n- w 移动到下一个单词的首字母\n- e 移动单词的末尾\n- $ 移动光标到行尾\n- ^ 移动光标到行首\n- 0 移动光标到行首\n- gg 当前光标直接跳转到文件第一行\n- G 当前光标直接跳转到文件最后一行\n- crtl-o 回到较旧位置\n- ctrl-i 回到较新位置\n- % 移动到配对的相应括号处\n- zz 将当前行移动到中间(移动屏幕)\n- zt 将当前行移动到第一行(移动屏幕)\n- crtl-f 往上移动一个屏幕\n- crtl-u 往下移动一个屏幕\n- f {w} 移动到{w}字母上\n\n### 更改\n- u 撤销上一次操作\n- U 撤销整行的操作\n- o 可以在光标下方打开新的一行并进入插入模式\n- O 可以在光标上方打开新的一行\n- a 光标之后插入文本\n- A 移动到行尾并进入插入模式\n- r 替换\n- R 可连续替换多个字符\n- crtl-r 撤销掉撤销的命令\n- ctrl-g 用于显示当前光标所在位置和文件状态信息\n- dd 删除整行\n- de 当前光标位置删除到单词末尾\n- dw 当前光标位置删除到下一个单词首部\n- d$ 当前光标位置删除到行尾\n- ce 当前光标位置删除到单词尾部, 并将删除的内容放入寄存器中, 进入插入模式\n- cw 与ce行为一直\n- dt) 删除直到右括号\n\n### 查找\n\n- / \n- ?\n- n 查找并移动到下一个匹配的单词\n- N 上一个\n\n### 替换\n\n- :s/the/the 当前行第一个匹配thee为替换为the\n- :s/thee/the/g 当前行所有thee为替换为the\n- :%s/old/new/g 文件内替换所有的字符串\n- :#,#s/old/new/g 两行内替换所有的字符串\n- :%s/old/new/gc 进行全文替换时询问用户确认每个替换需添加 c 标志\n\n###　执行外部命令\n\n- :!ls\n- :!dir\n\n\n### 复制粘贴\n\n- y 复制文本\n- p 粘贴文本\n- yw 复制一个单词 光标在单词末尾后\n- ye 复制一个单词 光标在单词末尾\n\n\n\nbash 使用 vi 键盘阵列\n\n```bash\nset -o vi\n```\n\n### 终端快捷键\n\n- ctrl+a: 移动到行首\n- ctrl+e: 移动到行尾\n- ctrl+b: 回移一个字符\n- ctrl+f: 前移一个字符\n- ctrl+r: 搜索历史命令\n- ctrl+p: 上一个命令\n- ctrl+n：下一个命令\n- ctrl+h: 清除前一个字符\n- ctrl+u: 清除当前命令\n- ctrl+l: 清屏，替代 clear 命令\n\n\n### 临时退出vim环境\n\n1. Ctrl-z 命令将当前的 Vi/Vim 进程放到后台执行，之后 shell 环境即可为你所用；fg 命令则将位于后台的 Vi/Vim 进程放到前台执行，这样我们就再次进入 Vi/Vim 操作界面并恢复到原先的编辑状态。\n\n2. 在 Vi/Vim 的正常模式下输入 :sh即可进入 Linux/Unix shell 环境。在要返回到 Vi/Vim 编辑环境时，输入 exit 命令即可'),(12,'调教日志3','teach-sss-3','<h2 id=\"going-to-try-go-all-the-way\">Going to try, go all the way</h2>\n<p>2018-6-4 - &gt; 2018-7-1</p>\n<p>优秀程序员是能自我驱动的, 找个感兴趣的方向去做吧\n1. 找个方向, 去做 .</p>\n<p>2018-7-1</p>\n<p>数据结构: 编写栈(stack)数据结构, 要求实现下列方法\n<img alt=\"\" src=\"https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png\" /></p>\n<p>2018-7-2 -&gt; 2018-7-4</p>\n<p>使用栈完成简单符号匹配, 如</p>\n<pre class=\"codehilite\"><code class=\"language-python\">print(per_checker(\'((()))\'))                                                   \nprint(per_checker(\'(())\'))                                                     \nprint(per_checker(\'{{([][])}()}\'))                                             \nprint(per_checker(\'[{()]\'))                                                    \nprint(per_checker(\'(){}\'))                                                     \nprint(per_checker(\'([)]\'))                                                     \nprint(per_checker(\'()[]\'))                                                     \nprint(per_checker(\'[(])\'))\nTrue\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse</code></pre>\n\n\n<p>2018-7-4 -&gt; 2018-7-8</p>\n<p>使用栈完成将中缀表达式转换成前缀, 和后缀表达式\n<img alt=\"\" src=\"https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table4.png\" />\n<img alt=\"\" src=\"https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure7.png\" />\n<img alt=\"\" src=\"https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure9.png\" /></p>\n<h4 id=\"_1\">由于不可抗力暂停</h4>','2018-06-04 05:51:08','2018-06-04 05:51:08',1,'## Going to try, go all the way\n2018-6-4 - > 2018-7-1\n\n优秀程序员是能自我驱动的, 找个感兴趣的方向去做吧\n1. 找个方向, 去做 .\n  \n2018-7-1\n\n数据结构: 编写栈(stack)数据结构, 要求实现下列方法\n![](https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png)\n\n2018-7-2 -> 2018-7-4\n\n使用栈完成简单符号匹配, 如\n\n```python\nprint(per_checker(\'((()))\'))                                                   \nprint(per_checker(\'(())\'))                                                     \nprint(per_checker(\'{{([][])}()}\'))                                             \nprint(per_checker(\'[{()]\'))                                                    \nprint(per_checker(\'(){}\'))                                                     \nprint(per_checker(\'([)]\'))                                                     \nprint(per_checker(\'()[]\'))                                                     \nprint(per_checker(\'[(])\'))\nTrue\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\n```\n\n2018-7-4 -> 2018-7-8\n\n使用栈完成将中缀表达式转换成前缀, 和后缀表达式\n![](https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table4.png)\n![](https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure7.png)\n![](https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure9.png)\n\n#### 由于不可抗力暂停'),(13,'解决tmux下使用默认dircolors','solve-tmux-dircolors','<p>最近我开始使用tmux, 但是在我的tmux上只能使用Ubuntu默认的dircolors, 然后特别的难看.</p>\n<p><img alt=\"20185008001.png\" src=\"https://buglan.org/static/images/2018-06/2018-50-08-001.png\" /></p>\n<p>直接使用dircolors也不起作用,\n后来我了解到颜色是通过一个叫LS_COLORS的值来保存的.</p>\n<pre class=\"codehilite\"><code class=\"language-conf\">LS_COLORS=\'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:\';\nexport LS_COLORS</code></pre>\n\n\n<p>然后我~/.zshrc 中加入了如下设置, 完美解决了tmux中dircolors的显示问题</p>\n<pre class=\"codehilite\"><code class=\"language-bash\">if  [ -f $HOME/.dircolors ];then\n        source $HOME/.dircolors;\nfi</code></pre>\n\n\n<p><img alt=\"20185608001.png\" src=\"https://buglan.org/static/images/2018-06/2018-56-08-001.png\" /></p>\n<p>我的<a href=\"https://github.com/BUGLAN/dotfiles\">.dircolors</a>文件</p>','2018-06-08 08:43:33','2018-06-08 08:43:33',2,'最近我开始使用tmux, 但是在我的tmux上只能使用Ubuntu默认的dircolors, 然后特别的难看.\n\n![20185008001.png](https://buglan.org/static/images/2018-06/2018-50-08-001.png)\n\n直接使用dircolors也不起作用,\n后来我了解到颜色是通过一个叫LS_COLORS的值来保存的.\n\n```conf\nLS_COLORS=\'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:\';\nexport LS_COLORS\n```\n\n然后我~/.zshrc 中加入了如下设置, 完美解决了tmux中dircolors的显示问题\n\n```bash\nif  [ -f $HOME/.dircolors ];then\n        source $HOME/.dircolors;\nfi\n```\n![20185608001.png](https://buglan.org/static/images/2018-06/2018-56-08-001.png)\n\n我的[.dircolors](https://github.com/BUGLAN/dotfiles)文件'),(14,'ArchLinux-i3wm安装与配置','archlinxu-i3wm-config','<p><img alt=\"i3wm.jpg\" src=\"https://buglan.org/static/images/2018-06/i3wm.jpg\" /></p>\n<p>占坑</p>\n<h3 id=\"_1\">截屏</h3>\n<ul>\n<li>sleep 5;import 213.png    //等待5秒截屏</li>\n<li>import -frame    123.jpg     //截取鼠标点击的那个窗口</li>\n<li>import -windows root   123.png  //截取全屏幕!</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>q</td>\n<td>q</td>\n</tr>\n<tr>\n<td>repository</td>\n<td>仓库</td>\n</tr>\n<tr>\n<td>attribute</td>\n<td>属性</td>\n</tr>\n<tr>\n<td>bentchmark</td>\n<td>基准测试</td>\n</tr>\n<tr>\n<td>indent</td>\n<td>缩进</td>\n</tr>\n<tr>\n<td>reference</td>\n<td>参考</td>\n</tr>\n<tr>\n<td>algorithm</td>\n<td>算法</td>\n</tr>\n<tr>\n<td>efficient</td>\n<td>高效</td>\n</tr>\n<tr>\n<td>efficient</td>\n<td>高效</td>\n</tr>\n<tr>\n<td>abstract data type</td>\n<td>抽象数据类型</td>\n</tr>\n<tr>\n<td>review</td>\n<td>复习,评论</td>\n</tr>\n<tr>\n<td>station</td>\n<td>站</td>\n</tr>\n<tr>\n<td>store</td>\n<td>商店</td>\n</tr>\n<tr>\n<td>arguments</td>\n<td>参数</td>\n</tr>\n<tr>\n<td>buffer</td>\n<td>缓冲区</td>\n</tr>\n<tr>\n<td>indentifer</td>\n<td>标识符</td>\n</tr>\n<tr>\n<td>measurement</td>\n<td>度量</td>\n</tr>\n<tr>\n<td>constant</td>\n<td>常量</td>\n</tr>\n<tr>\n<td>logarithmic</td>\n<td>对数</td>\n</tr>\n<tr>\n<td>linear</td>\n<td>线性</td>\n</tr>\n<tr>\n<td>log linear</td>\n<td>对数线性</td>\n</tr>\n<tr>\n<td>quadratic</td>\n<td>二次</td>\n</tr>\n<tr>\n<td>cubic</td>\n<td>立方</td>\n</tr>\n<tr>\n<td>exponential</td>\n<td>指数的</td>\n</tr>\n<tr>\n<td>contain</td>\n<td>包含</td>\n</tr>\n<tr>\n<td>stack</td>\n<td>栈</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>二进制</td>\n</tr>\n<tr>\n<td>remainder</td>\n<td>余数</td>\n</tr>\n<tr>\n<td>conventions</td>\n<td>公约</td>\n</tr>\n<tr>\n<td>prefix</td>\n<td>前缀</td>\n</tr>\n<tr>\n<td>infix</td>\n<td>中缀</td>\n</tr>\n<tr>\n<td>postfix</td>\n<td>后缀</td>\n</tr>\n<tr>\n<td>figure</td>\n<td>数字, 图形</td>\n</tr>\n<tr>\n<td>container</td>\n<td>容器</td>\n</tr>\n<tr>\n<td>token</td>\n<td>令牌, 符号, 记号</td>\n</tr>\n<tr>\n<td>initialize</td>\n<td>初始化</td>\n</tr>\n<tr>\n<td>fifo</td>\n<td>先进先出. first in, first out</td>\n</tr>\n<tr>\n<td>project</td>\n<td>项目, 工程</td>\n</tr>\n<tr>\n<td>unordered</td>\n<td>无序</td>\n</tr>\n<tr>\n<td>current</td>\n<td>当前的</td>\n</tr>\n<tr>\n<td>traversal</td>\n<td>遍历</td>\n</tr>\n<tr>\n<td>ambiguous</td>\n<td>模糊不清, 有歧义的</td>\n</tr>\n<tr>\n<td>ordered</td>\n<td>有序的</td>\n</tr>\n<tr>\n<td>rescursive</td>\n<td>递归</td>\n</tr>\n<tr>\n<td>script</td>\n<td>脚本</td>\n</tr>\n<tr>\n<td>sequence</td>\n<td>序列</td>\n</tr>\n<tr>\n<td>frame</td>\n<td>框架, 结构</td>\n</tr>\n<tr>\n<td>framework</td>\n<td>框架</td>\n</tr>\n<tr>\n<td>square</td>\n<td>平方</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>注释</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"codehilite\"><code class=\"language-bash\">一些表格</code></pre>','2018-06-12 07:55:37','2018-06-12 07:55:37',2,'![i3wm.jpg](https://buglan.org/static/images/2018-06/i3wm.jpg)\n\n占坑\n### 截屏\n- sleep 5;import 213.png    //等待5秒截屏\n- import -frame    123.jpg     //截取鼠标点击的那个窗口\n- import -windows root   123.png  //截取全屏幕!\n\n\n|1|2|\n|----|----|\n|q|q|\n| repository         | 仓库                          |\n| attribute          | 属性                          |\n| bentchmark         | 基准测试                      |\n| indent             | 缩进                          |\n| reference          | 参考                          |\n| algorithm          | 算法                          |\n| efficient          | 高效                          |\n| efficient          | 高效                          |\n| abstract data type | 抽象数据类型                  |\n| review             | 复习,评论                     |\n| station            | 站                            |\n| store              | 商店                          |\n| arguments          | 参数                          |\n| buffer             | 缓冲区                        |\n| indentifer         | 标识符                        |\n| measurement        | 度量                          |\n| constant           | 常量                          |\n| logarithmic        | 对数                          |\n| linear             | 线性                          |\n| log linear         | 对数线性                      |\n| quadratic          | 二次                          |\n| cubic              | 立方                          |\n| exponential        | 指数的                        |\n| contain            | 包含                          |\n| stack              | 栈                            |\n| binary             | 二进制                        |\n| remainder          | 余数                          |\n| conventions        | 公约                          |\n| prefix             | 前缀                          |\n| infix              | 中缀                          |\n| postfix            | 后缀                          |\n| figure             | 数字, 图形                    |\n| container          | 容器                          |\n| token              | 令牌, 符号, 记号              |\n| initialize         | 初始化                        |\n| fifo               | 先进先出. first in, first out |\n| project            | 项目, 工程                    |\n| unordered          | 无序                          |\n| current            | 当前的                        |\n| traversal          | 遍历                          |\n| ambiguous          | 模糊不清, 有歧义的            |\n| ordered            | 有序的                        |\n| rescursive         | 递归                          |\n| script             | 脚本                          |\n| sequence           | 序列                          |\n| frame              | 框架, 结构                    |\n| framework          | 框架                          |\n| square             | 平方                          |\n| comments           | 注释                          |\n\n\n```bash\n一些表格\n```');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_tag`
--

DROP TABLE IF EXISTS `article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) DEFAULT NULL,
  `tag_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `article_id` (`article_id`),
  KEY `tag_id` (`tag_id`)
) ENGINE=MyISAM AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_tag`
--

LOCK TABLES `article_tag` WRITE;
/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
INSERT INTO `article_tag` VALUES (1,1,1),(22,14,4),(6,5,4),(5,4,4),(8,8,1),(21,12,1),(20,11,6),(19,5,6),(18,11,4);
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(58) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (1,'崧崧崧调教日志','2018-05-15 04:07:28','2018-05-15 04:07:28'),(2,'Linux','2018-05-17 07:59:44','2018-05-17 07:59:44');
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(58) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (1,'教程','2018-05-15 04:06:18','2018-05-15 04:13:30'),(4,'Linux','2018-05-20 05:58:10','2018-05-20 05:58:10'),(6,'vim','2018-05-26 09:14:03','2018-05-26 09:14:03');
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL,
  `password` varchar(55) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES (1,'buglan','lansheng','2018-05-15 03:24:07','2018-05-15 03:24:07');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-08-14 16:26:18
